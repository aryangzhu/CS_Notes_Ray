<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.28.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.13.5/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.7.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.13.5"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.13.5/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, root, jsonOptions) => {
        const markmap = getMarkmap();
        window.mm = markmap.Markmap.create('svg#mindmap', (getOptions || markmap.deriveOptions)(jsonOptions), root);
      })(() => window.markmap,null,{"type":"root","depth":0,"content":"","children":[{"type":"heading","depth":1,"payload":{"lines":[0,1]},"content":"第一章 走入并行","children":[{"type":"heading","depth":2,"payload":{"lines":[1,2]},"content":"必须知道的几个概念","children":[{"type":"heading","depth":3,"payload":{"lines":[2,3]},"content":"同步和异步"},{"type":"heading","depth":3,"payload":{"lines":[5,6]},"content":"并发与并行"},{"type":"heading","depth":3,"payload":{"lines":[8,9]},"content":"临界区"},{"type":"heading","depth":3,"payload":{"lines":[10,11]},"content":"阻塞与非阻塞"},{"type":"heading","depth":3,"payload":{"lines":[12,13]},"content":"死锁、饥饿、活锁","children":[{"type":"heading","depth":4,"payload":{"lines":[13,14]},"content":"死锁"},{"type":"heading","depth":4,"payload":{"lines":[24,25]},"content":"饥饿"},{"type":"heading","depth":4,"payload":{"lines":[26,27]},"content":"活锁"}]}]},{"type":"heading","depth":2,"payload":{"lines":[28,29]},"content":"并发级别","children":[{"type":"heading","depth":3,"payload":{"lines":[29,30]},"content":"阻塞"},{"type":"heading","depth":3,"payload":{"lines":[31,32]},"content":"无饥饿"},{"type":"heading","depth":3,"payload":{"lines":[33,34]},"content":"无障碍"},{"type":"heading","depth":3,"payload":{"lines":[36,37]},"content":"无锁"},{"type":"heading","depth":3,"payload":{"lines":[39,40]},"content":"无等待"}]},{"type":"heading","depth":2,"payload":{"lines":[42,43]},"content":"并行有关的两个定律","children":[{"type":"heading","depth":3,"payload":{"lines":[43,44]},"content":"Amdahal定律"},{"type":"heading","depth":3,"payload":{"lines":[44,45]},"content":"Gustafson定律"}]},{"type":"heading","depth":2,"payload":{"lines":[45,46]},"content":"回到Java:JMM","children":[{"type":"heading","depth":3,"payload":{"lines":[47,48]},"content":"原子性(Atomicity)"},{"type":"heading","depth":3,"payload":{"lines":[49,50]},"content":"可见性(Visibility)"},{"type":"heading","depth":3,"payload":{"lines":[51,52]},"content":"有序性(Ordering)","children":[{"type":"heading","depth":4,"payload":{"lines":[53,54]},"content":"哪些指令不能重排","children":[{"type":"heading","depth":5,"payload":{"lines":[54,55]},"content":"程序顺序原则"},{"type":"heading","depth":5,"payload":{"lines":[56,57]},"content":"volatile规则"},{"type":"heading","depth":5,"payload":{"lines":[58,59]},"content":"锁规则","children":[{"type":"heading","depth":6,"payload":{"lines":[60,61]},"content":"传递性"}]},{"type":"heading","depth":5,"payload":{"lines":[63,64]},"content":"线程的start()先于它的每一个动作"},{"type":"heading","depth":5,"payload":{"lines":[65,66]},"content":"线程的所有操作先于线程的终结(Thread.join())"},{"type":"heading","depth":5,"payload":{"lines":[66,67]},"content":"线程的中断(interrupt())先于被中断线程的代码"},{"type":"heading","depth":5,"payload":{"lines":[67,68]},"content":"对象的构造函数执行、结束于finalize()方法"}]}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[69,70]},"content":"第二章 Java并行程序基础","children":[{"type":"heading","depth":2,"payload":{"lines":[70,71]},"content":"有关线程必知的事","children":[{"type":"heading","depth":3,"payload":{"lines":[71,72]},"content":"进程与线程"},{"type":"heading","depth":3,"payload":{"lines":[75,76]},"content":"线程的6种状态"}]},{"type":"heading","depth":2,"payload":{"lines":[76,77]},"content":"初始线程：线程的基本操作","children":[{"type":"heading","depth":3,"payload":{"lines":[77,78]},"content":"新建"},{"type":"heading","depth":3,"payload":{"lines":[78,79]},"content":"中止"},{"type":"heading","depth":3,"payload":{"lines":[79,80]},"content":"中断"},{"type":"heading","depth":3,"payload":{"lines":[80,81]},"content":"等待(wait)与唤醒(通知 notify)"},{"type":"heading","depth":3,"payload":{"lines":[82,83]},"content":"挂起(suspend)与继续执行(resume)"},{"type":"heading","depth":3,"payload":{"lines":[83,84]},"content":"等待线程结束(join)与谦让(yield)"}]},{"type":"heading","depth":2,"payload":{"lines":[84,85]},"content":"volatile与JMM(Java内存模型)"},{"type":"heading","depth":2,"payload":{"lines":[85,86]},"content":"分门别类的管理(线程组)"},{"type":"heading","depth":2,"payload":{"lines":[86,87]},"content":"驻守后台的线程(守护线程)"},{"type":"heading","depth":2,"payload":{"lines":[87,88]},"content":"先干重要的事(线程优先级)"},{"type":"heading","depth":2,"payload":{"lines":[88,89]},"content":"线程安全的概念与synchronized"},{"type":"heading","depth":2,"payload":{"lines":[89,90]},"content":"程序中的幽灵(隐蔽的错误)"}]},{"type":"heading","depth":1,"payload":{"lines":[90,91]},"content":"第三章 JDK下的并发包","children":[{"type":"heading","depth":2,"payload":{"lines":[91,92]},"content":"同步控制","children":[{"type":"heading","depth":3,"payload":{"lines":[92,93]},"content":"synchronized的功能扩展ReentrantLock(可重入锁)","children":[{"type":"heading","depth":4,"payload":{"lines":[93,94]},"content":"中断响应"},{"type":"heading","depth":4,"payload":{"lines":[100,101]},"content":"锁申请等待限时"},{"type":"heading","depth":4,"payload":{"lines":[101,102]},"content":"公平锁"},{"type":"heading","depth":4,"payload":{"lines":[102,103]},"content":"ReentrantLock常用API","children":[{"type":"heading","depth":5,"payload":{"lines":[103,104]},"content":"lock()"},{"type":"heading","depth":5,"payload":{"lines":[105,106]},"content":"lockInterruptibly()"},{"type":"heading","depth":5,"payload":{"lines":[107,108]},"content":"tryLock()"},{"type":"heading","depth":5,"payload":{"lines":[109,110]},"content":"tryLock(long time,TimeUnit unit)"},{"type":"heading","depth":5,"payload":{"lines":[111,112]},"content":"unlock()"}]}]},{"type":"heading","depth":3,"payload":{"lines":[113,114]},"content":"重入锁的搭档:Condition条件","children":[{"type":"heading","depth":4,"payload":{"lines":[114,115]},"content":"常用API","children":[{"type":"heading","depth":5,"payload":{"lines":[115,116]},"content":"await()"},{"type":"heading","depth":5,"payload":{"lines":[117,118]},"content":"awaitUniterruptibly()"},{"type":"heading","depth":5,"payload":{"lines":[119,120]},"content":"singal()"}]},{"type":"heading","depth":4,"payload":{"lines":[121,122]},"content":"ArrayBlockingQueue的put方法"}]},{"type":"heading","depth":3,"payload":{"lines":[122,123]},"content":"允许多个线程同时访问:信号量(Semaphore)","children":[{"type":"heading","depth":4,"payload":{"lines":[123,124]},"content":"常用API","children":[{"type":"heading","depth":5,"payload":{"lines":[125,126]},"content":"public Semaphore(int permits)"},{"type":"heading","depth":5,"payload":{"lines":[126,127]},"content":"public Semaphore(int permits,boolean fair)"},{"type":"heading","depth":5,"payload":{"lines":[129,130]},"content":"public void acquire()"},{"type":"heading","depth":5,"payload":{"lines":[131,132]},"content":"public void acquireUninterruptibly()"},{"type":"heading","depth":5,"payload":{"lines":[133,134]},"content":"public boolean tryAcquire()"},{"type":"heading","depth":5,"payload":{"lines":[135,136]},"content":"public boolean tryAcquire(long timeout,TimeUnit unit)"},{"type":"heading","depth":5,"payload":{"lines":[136,137]},"content":"public void release()"}]}]},{"type":"heading","depth":3,"payload":{"lines":[138,139]},"content":"ReadWriteLock读写锁"},{"type":"heading","depth":3,"payload":{"lines":[143,144]},"content":"倒计时器CountDownLatch","children":[{"type":"heading","depth":4,"payload":{"lines":[145,146]},"content":"常用API","children":[{"type":"heading","depth":5,"payload":{"lines":[146,147]},"content":"countDown()"},{"type":"heading","depth":5,"payload":{"lines":[147,148]},"content":"CountDownLatch(int count)"}]}]},{"type":"heading","depth":3,"payload":{"lines":[148,149]},"content":"循环栅栏:CyclicBarrier","children":[{"type":"heading","depth":4,"payload":{"lines":[151,152]},"content":"常用API","children":[{"type":"heading","depth":5,"payload":{"lines":[152,153]},"content":"await()"}]}]},{"type":"heading","depth":3,"payload":{"lines":[154,155]},"content":"线程阻塞工具类LockSupport","children":[{"type":"heading","depth":4,"payload":{"lines":[158,159]},"content":"常用API","children":[{"type":"heading","depth":5,"payload":{"lines":[159,160]},"content":"park()"},{"type":"heading","depth":5,"payload":{"lines":[161,162]},"content":"parkNanos()"},{"type":"heading","depth":5,"payload":{"lines":[162,163]},"content":"parkUntil()"}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[164,165]},"content":"线程复用:线程池","children":[{"type":"ordered_list","depth":3,"payload":{"lines":[166,169],"startIndex":1},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[166,167],"index":1},"content":"1. 创建和小会线程都会花费时间"},{"type":"list_item","depth":4,"payload":{"lines":[167,169],"index":2},"content":"2. 线程本身也会占用内存空间<br>\n所以,线程的使用必须掌握一个度,在有限的范围内,增加线程的数量可以明显提高系统的吞吐量"}]},{"type":"heading","depth":3,"payload":{"lines":[169,170]},"content":"什么是线程池"},{"type":"heading","depth":3,"payload":{"lines":[171,172]},"content":"不要重复发明轮子:JDK对线程池的支持","children":[{"type":"heading","depth":4,"payload":{"lines":[177,178]},"content":"常用API","children":[{"type":"heading","depth":5,"payload":{"lines":[178,179]},"content":"public static ExecutorService newFixedThreadPool()"},{"type":"heading","depth":5,"payload":{"lines":[180,181]},"content":"public static ExecutorService newSingleThreadExecutor()"},{"type":"heading","depth":5,"payload":{"lines":[182,183]},"content":"public static ExecutorService newCachedThreadPool()"},{"type":"heading","depth":5,"payload":{"lines":[184,185]},"content":"public static ScheduledExecutorService newSingleThreadScheduledExecutorS()"},{"type":"heading","depth":5,"payload":{"lines":[186,187]},"content":"public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)"}]}]},{"type":"heading","depth":3,"payload":{"lines":[188,189]},"content":"核心线程池的内部实现","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token class-name\">ExecutorService</span> <span class=\"token function\">newFixedThreadPool</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> nThreads<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span>nThreads<span class=\"token punctuation\">,</span>nThreads<span class=\"token punctuation\">,</span><span class=\"token number\">0L</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span>MILLISECONDS<span class=\"token punctuation\">,</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">LinkedBlokingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"type":"fence","depth":4,"content":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">ThreadPoolExecutor</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> corePoolSize<span class=\"token punctuation\">,</span><span class=\"token keyword\">int</span> maximumPoolSize<span class=\"token punctuation\">,</span><span class=\"token keyword\">long</span> keepAliveTime<span class=\"token punctuation\">,</span><span class=\"token class-name\">TimeUnit</span> unit<span class=\"token punctuation\">,</span><span class=\"token class-name\">BlockingQueue</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">></span></span> workQueue<span class=\"token punctuation\">,</span><span class=\"token class-name\">ThreadFactory</span> threadFactory<span class=\"token punctuation\">,</span><span class=\"token class-name\">RejectedExecutionHandler</span> handler<span class=\"token punctuation\">)</span>\n</code></pre>\n"},{"type":"ordered_list","depth":4,"payload":{"lines":[210,218],"startIndex":1},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[210,212],"index":1},"content":"1. 直接提交的队列<br>\n该功能由SynchronousQueue对象提供。任务不会真实的保存,总是将新任务提交给线程执行(后面书上的描述???)"},{"type":"list_item","depth":5,"payload":{"lines":[212,214],"index":2},"content":"2. 有界的任务队列ArrauBlockingQueue(int capacity)<br>\n由ArrayBlockingQueue实现。如果线程池的实际线程数小于corePoolSize,则会优先创建新的线程。如果大于corePoolSize,则会将新任务加入等待队列。若等待队列已满,无法加入。"},{"type":"list_item","depth":5,"payload":{"lines":[214,216],"index":3},"content":"3. 无界的任务队列<br>\n无界的任务队列:无界任务队列可以通过LinkedBlockingQueue类实现,与有界的任务队列相比,除非系统资源耗尽,不存在入队失败的情况。"},{"type":"list_item","depth":5,"payload":{"lines":[216,218],"index":4},"content":"4. 优先任务队列<br>\n带着优先级的无界队列,通过PriorityBlockingQueue实现。"}]}]},{"type":"heading","depth":3,"payload":{"lines":[218,219]},"content":"超过负载之后的拒绝策略","children":[{"type":"list_item","depth":4,"payload":{"lines":[221,222],"index":1},"content":"1. AbortPolicy策略:该策略会直接抛出异常,阻止系统正常工作。"},{"type":"list_item","depth":4,"payload":{"lines":[222,223],"index":2},"content":"2. CallerRunsPolicy策略:只要线程池未关闭,改策略直接在调用者线程中，运行当前被丢弃任务。"},{"type":"list_item","depth":4,"payload":{"lines":[223,224],"index":3},"content":"3. DiscardOledestPolicy策略:该策略将丢弃最老的一个请求,也是就是即将被执行的任务。"},{"type":"list_item","depth":4,"payload":{"lines":[224,226],"index":4},"content":"4. DiscardPolicy:默默丢弃无法处理的任务。<br>\n以上策略均实现了RejectExectionHandler接口，也可以自己扩展接口。"}]},{"type":"heading","depth":3,"payload":{"lines":[226,227]},"content":"自定义线程的创建:ThreadFactory"},{"type":"heading","depth":3,"payload":{"lines":[227,228]},"content":"扩展线程池"},{"type":"heading","depth":3,"payload":{"lines":[234,235]},"content":"优化线程池线程数量"},{"type":"heading","depth":3,"payload":{"lines":[235,236]},"content":"线程池中的堆栈"},{"type":"heading","depth":3,"payload":{"lines":[242,243]},"content":"分而治之:Fork/Join框架","children":[{"type":"heading","depth":4,"payload":{"lines":[244,245]},"content":"常用API","children":[{"type":"heading","depth":5,"payload":{"lines":[245,246]},"content":"public <T> ForkJoinTask<T> submit(ForJoinTask<T> task)"}]}]}]},{"type":"heading","depth":2,"payload":{"lines":[247,248]},"content":"JDK的并发容器","children":[{"type":"heading","depth":3,"payload":{"lines":[249,250]},"content":"并发集合简介","children":[{"type":"ordered_list","depth":4,"payload":{"lines":[250,255],"startIndex":1},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[250,251],"index":1},"content":"1. ConcurrentHashMap:这是一个高效的并发HashMap。<strong>线程安全的HashMap</strong>。"},{"type":"list_item","depth":5,"payload":{"lines":[251,252],"index":2},"content":"2. CopyOnWriteArrayList:适合<strong>读多写少</strong>的场合。"},{"type":"list_item","depth":5,"payload":{"lines":[252,253],"index":3},"content":"3. ConcurrentLinkedQueue:高效的并发队列,使用链表实现。可以看做是一个<strong>线程安全的Linkedlist</strong>。"},{"type":"list_item","depth":5,"payload":{"lines":[253,254],"index":4},"content":"4. BlockingQueue：这是一个接口,JDK内部通过链表和数组实现。表示阻塞队列,适合作为<strong>数据共享的通道</strong>。"},{"type":"list_item","depth":5,"payload":{"lines":[254,255],"index":5},"content":"5. ConcurrentSkipListMap:跳表的实现。Map,使用跳表的数据结构进行快速查找。"}]},{"type":"heading","depth":4,"payload":{"lines":[255,256]},"content":"Map的安全集合ConcurrentHashMap"},{"type":"heading","depth":4,"payload":{"lines":[256,257]},"content":"List的线程安全"},{"type":"heading","depth":4,"payload":{"lines":[257,258]},"content":"高效的读写队列:ConcurrentLinkedQueue"},{"type":"heading","depth":4,"payload":{"lines":[258,259]},"content":"不变模式下的CopyOnWriteArrayList"},{"type":"heading","depth":4,"payload":{"lines":[259,260]},"content":"数据共享通道BlockingQueue"},{"type":"heading","depth":4,"payload":{"lines":[260,261]},"content":"随机数据结构:跳表(SkipList)"}]}]}]},{"type":"heading","depth":1,"payload":{"lines":[261,262]},"content":"第四章 关于锁和锁的优化","children":[{"type":"heading","depth":2,"payload":{"lines":[264,265]},"content":"提升锁性能的建议","children":[{"type":"heading","depth":3,"payload":{"lines":[265,266]},"content":"减少锁的持有时间","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">Matcher</span> <span class=\"token function\">matcher</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">CharSequence</span> input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>complied<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token function\">synchornized</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>complied<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span> <span class=\"token comment\">//个人猜测为了一种可能为了线程安全，还有一种可能为了代码的健壮性</span>\n                <span class=\"token function\">complied</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token class-name\">Mathcer</span> m<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">Matcher</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span>input<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> m<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"}]},{"type":"heading","depth":3,"payload":{"lines":[281,282]},"content":"减少锁的粒度","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-java\"><code class=\"language-java\"> <span class=\"token keyword\">public</span> <span class=\"token class-name\">V</span> <span class=\"token function\">put</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">K</span> key<span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span> value<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token class-name\">Segment</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span> s<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//先处理空指针</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>value<span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NullPointExeception</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">//对key进行hash处理</span>\n    <span class=\"token keyword\">int</span> hash<span class=\"token operator\">=</span><span class=\"token function\">hsah</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">//获得对应的段的序号</span>\n    <span class=\"token keyword\">int</span> j<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span>hash<span class=\"token operator\">>>></span>segmentShift<span class=\"token punctuation\">)</span><span class=\"token operator\">&amp;</span>segmentMask<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>s<span class=\"token operator\">=</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Segment</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">K</span><span class=\"token punctuation\">,</span><span class=\"token class-name\">V</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">)</span>UNSAFE<span class=\"token punctuation\">.</span><span class=\"token function\">getObject</span><span class=\"token punctuation\">(</span>segments<span class=\"token punctuation\">,</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">&lt;&lt;</span>SSHIFT<span class=\"token punctuation\">)</span><span class=\"token operator\">+</span>SBASE<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token operator\">==</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">//上面的if进行了一次非可变性的检验，确保在确认的段里(过于拗口)</span>\n        s<span class=\"token operator\">=</span><span class=\"token function\">ensureSegment</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">put</span><span class=\"token punctuation\">(</span>key<span class=\"token punctuation\">,</span>hash<span class=\"token punctuation\">,</span>value<span class=\"token punctuation\">,</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n</code></pre>\n"}]},{"type":"heading","depth":3,"payload":{"lines":[308,309]},"content":"读写分离锁来替换独占锁"},{"type":"heading","depth":3,"payload":{"lines":[310,311]},"content":"锁分离","children":[{"type":"fence","depth":4,"content":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> takeLock<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//被take,poll操作线程持有的锁</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Conditional</span> notEmpty<span class=\"token operator\">=</span>takeLock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">ReentrantLock</span> putLock<span class=\"token operator\">=</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//被put,offer操作线程持有的锁。</span>\n<span class=\"token keyword\">private</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Conditional</span> notFull<span class=\"token operator\">=</span>putLock<span class=\"token punctuation\">.</span><span class=\"token function\">newCondition</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n"},{"type":"fence","depth":4,"content":"<pre class=\"language-java\"><code class=\"language-java\"></code></pre>\n"}]},{"type":"heading","depth":3,"payload":{"lines":[324,325]},"content":"锁粗化"}]},{"type":"heading","depth":2,"payload":{"lines":[326,327]},"content":"Java对锁优化的努力","children":[{"type":"heading","depth":3,"payload":{"lines":[327,328]},"content":"锁偏向"},{"type":"heading","depth":3,"payload":{"lines":[329,330]},"content":"轻量级锁"},{"type":"heading","depth":3,"payload":{"lines":[330,331]},"content":"自旋锁"},{"type":"heading","depth":3,"payload":{"lines":[331,332]},"content":"锁的消除"}]},{"type":"heading","depth":2,"payload":{"lines":[332,333]},"content":"ThreadLocal","children":[{"type":"heading","depth":3,"payload":{"lines":[333,334]},"content":"简单使用"},{"type":"heading","depth":3,"payload":{"lines":[334,335]},"content":"ThreadLocal的实现原理"},{"type":"heading","depth":3,"payload":{"lines":[335,336]},"content":"对性能有何帮助"}]},{"type":"heading","depth":2,"payload":{"lines":[336,337]},"content":"无锁","children":[{"type":"heading","depth":3,"payload":{"lines":[337,338]},"content":"比较交换CAS"},{"type":"heading","depth":3,"payload":{"lines":[338,339]},"content":"原子类(AtomicInteger)"},{"type":"heading","depth":3,"payload":{"lines":[339,340]},"content":"Java中的指针Unsafe类"},{"type":"heading","depth":3,"payload":{"lines":[340,341]},"content":"无锁的对象引用:AtomicReference"},{"type":"heading","depth":3,"payload":{"lines":[341,342]},"content":"带有时间戳的对象引用"},{"type":"heading","depth":3,"payload":{"lines":[342,343]},"content":"无锁数组:AtomicIntegerArray"},{"type":"heading","depth":3,"payload":{"lines":[343,344]},"content":"让普通变量也享受原子操作:AtomicIntegerFieldUpdater"},{"type":"heading","depth":3,"payload":{"lines":[344,345]},"content":"无锁的Vector实现"},{"type":"heading","depth":3,"payload":{"lines":[345,346]},"content":"细看SynchronousQueue的实现"}]},{"type":"heading","depth":2,"payload":{"lines":[346,347]},"content":"有关死锁"}]},{"type":"heading","depth":1,"payload":{"lines":[347,348]},"content":"并行模式与算法","children":[{"type":"heading","depth":2,"payload":{"lines":[348,349]},"content":"单例模式"},{"type":"heading","depth":2,"payload":{"lines":[349,350]},"content":"不变模式(final关键字)"},{"type":"heading","depth":2,"payload":{"lines":[350,351]},"content":"生产者-消费者模式"},{"type":"heading","depth":2,"payload":{"lines":[351,352]},"content":"高性能的无锁的实现"},{"type":"heading","depth":2,"payload":{"lines":[352,353]},"content":"Future模式","children":[{"type":"heading","depth":3,"payload":{"lines":[354,355]},"content":"Future模式的主要角色","children":[{"type":"list_item","depth":4,"payload":{"lines":[355,356],"index":1},"content":"1. Main 系统启动,调用Client发出请求"},{"type":"list_item","depth":4,"payload":{"lines":[356,357],"index":2},"content":"2. Client 返回Data对象,立即返回FutureData,并开启ClientThread线程装配RealData"},{"type":"list_item","depth":4,"payload":{"lines":[357,358],"index":3},"content":"3. Data 返回数据的接口"},{"type":"list_item","depth":4,"payload":{"lines":[358,359],"index":4},"content":"4. FutureData Future数据,构造很快,但是一个虚拟的数据,需要装配RealData"},{"type":"list_item","depth":4,"payload":{"lines":[359,360],"index":5},"content":"5. 真实数据,其构造是比较慢的"}]}]},{"type":"heading","depth":2,"payload":{"lines":[360,361]},"content":"并行流水线"},{"type":"heading","depth":2,"payload":{"lines":[361,362]},"content":"并行搜索"},{"type":"heading","depth":2,"payload":{"lines":[362,363]},"content":"并行排序"},{"type":"heading","depth":2,"payload":{"lines":[363,364]},"content":"并行算法:矩阵算法"},{"type":"heading","depth":2,"payload":{"lines":[364,365]},"content":"NIO(准备好了再通知我)","children":[{"type":"heading","depth":3,"payload":{"lines":[370,371]},"content":"操作系统提供Soket编程的接口","children":[{"type":"heading","depth":4,"payload":{"lines":[371,372]},"content":"socket()函数"},{"type":"heading","depth":4,"payload":{"lines":[377,378]},"content":"bind()函数"},{"type":"heading","depth":4,"payload":{"lines":[380,381]},"content":"listen()、connect()函数"},{"type":"heading","depth":4,"payload":{"lines":[383,384]},"content":"accept()函数"},{"type":"heading","depth":4,"payload":{"lines":[385,386]},"content":"read()、write()"},{"type":"heading","depth":4,"payload":{"lines":[387,388]},"content":"close()函数"}]},{"type":"heading","depth":3,"payload":{"lines":[389,390]},"content":"JDK中的核心类","children":[{"type":"ordered_list","depth":4,"payload":{"lines":[391,402],"startIndex":1},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[391,392],"index":1},"content":"1. 服务器实例化一个<strong>ServerSocket对象</strong>*,表示通过服务器上的端口通信。"},{"type":"list_item","depth":5,"payload":{"lines":[392,393],"index":2},"content":"2. 服务器调用ServerSocket类的<strong>accept()</strong>方法,该方法将一直等待,直到客户端连接到服务器上给定的端口。"},{"type":"list_item","depth":5,"payload":{"lines":[393,394],"index":3},"content":"3. 服务器正在等待时,一个客户端实例化一个Socket对象,指定服务器名称和端口号来请求连接。"},{"type":"list_item","depth":5,"payload":{"lines":[394,395],"index":4},"content":"4. Socket类的构造函数将客户端连接到指定的服务器和端口号,如果通信被建立,则在客户端创建一个Socket对象能够与服务器进行通信(和3在同一步骤)。"},{"type":"list_item","depth":5,"payload":{"lines":[395,397],"index":5},"content":"5. 在服务器,accept()方法返回服务器上的一个新的socket引用,该socket连接到客户端的socket。<br>\n此外还有一个数据结构<strong>ByteBuffer</strong>,本质上就是一个数组。几个重要的参数:"},{"type":"list_item","depth":5,"payload":{"lines":[397,398],"index":6},"content":"6. 容量(Capacity)缓冲区能够容纳的数据元素的最大数量。容量在缓冲区创建时被设定,并且永远不能改变。"},{"type":"list_item","depth":5,"payload":{"lines":[398,399],"index":7},"content":"7. 上界(Limit)缓冲区里的数据的总数,代表了当前缓冲区一共有多少数据(这个参数下文会反复提到,filp()函数中会对这个值做修改)。"},{"type":"list_item","depth":5,"payload":{"lines":[399,400],"index":8},"content":"8. 位置(Position)下一个要被读或写的元素的位置。Position会自动由相应的get()和put()函数更新。"},{"type":"list_item","depth":5,"payload":{"lines":[400,402],"index":9},"content":"9. 标记(Mark)一个备忘位置。用于记录上一次读写的位置。<br>\n如果在ByteBuffer中放入了数据,然后想从中读取的话,就需要position这个字段放到想读的位置(那为什么不放这个字段呢？)"}]},{"type":"fence","depth":4,"content":"<pre class=\"language-java\"><code class=\"language-java\">    <span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Buffer</span> <span class=\"token function\">position</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> newPosition<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>newPosition <span class=\"token operator\">></span> limit <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>newPosition<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentExcetion</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        position<span class=\"token operator\">=</span>newPosition<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mark <span class=\"token operator\">></span> position<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            mark<span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"type":"fence","depth":4,"content":"<pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">final</span> <span class=\"token class-name\">Buffer</span> <span class=\"token function\">limit</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> newLimit<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>newLimit <span class=\"token operator\">></span> capacity <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>newLimit<span class=\"token operator\">&lt;</span><span class=\"token number\">0</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalArgumentExcetion</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    limit<span class=\"token operator\">=</span>newLimit<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>postion<span class=\"token operator\">></span> limit<span class=\"token punctuation\">)</span> position<span class=\"token operator\">=</span>limit<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>mark<span class=\"token operator\">></span>limit<span class=\"token punctuation\">)</span> mark<span class=\"token operator\">=</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"type":"ordered_list","depth":4,"payload":{"lines":[434,436],"startIndex":1},"content":"","children":[{"type":"list_item","depth":5,"payload":{"lines":[434,435],"index":1},"content":"1. 客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流"},{"type":"list_item","depth":5,"payload":{"lines":[435,436],"index":2},"content":"2. TCP双向通信,同一时刻可由客户端发送到服务器端,也可由服务器端发送到客户端。"}]},{"type":"heading","depth":4,"payload":{"lines":[437,438]},"content":"ServerSocket"},{"type":"heading","depth":4,"payload":{"lines":[439,440]},"content":"Socket"},{"type":"heading","depth":4,"payload":{"lines":[441,442]},"content":"InetAddress"}]},{"type":"heading","depth":3,"payload":{"lines":[443,444]},"content":"再看NIO服务器","children":[{"type":"heading","depth":4,"payload":{"lines":[446,447]},"content":"为什么会有Selector???"}]}]},{"type":"heading","depth":2,"payload":{"lines":[456,457]},"content":"AIO(读完了再通知我)","children":[{"type":"fence","depth":3,"content":"<pre class=\"language-java\"><code class=\"language-java\"> <span class=\"token comment\">//客户端请求的处理和接收</span>\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"server listen on\"</span><span class=\"token operator\">+</span>PORT<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token comment\">//注册事件和事件完成后的处理器</span>\n        server<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">CompletionHandler</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">AsynchronousSocketChannel</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">final</span> <span class=\"token class-name\">ByteBuffer</span> buffer<span class=\"token operator\">=</span><span class=\"token class-name\">ByteBuffer</span><span class=\"token punctuation\">.</span><span class=\"token function\">allocate</span><span class=\"token punctuation\">(</span><span class=\"token number\">1024</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">completed</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">AsynchronousSocketChannel</span> result<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> attachment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getName</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n                <span class=\"token class-name\">Future</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> writeResult<span class=\"token operator\">=</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n                    buffer<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    result<span class=\"token punctuation\">.</span><span class=\"token function\">read</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token class-name\">TimeUnit</span><span class=\"token punctuation\">.</span>SECONDS<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    buffer<span class=\"token punctuation\">.</span><span class=\"token function\">flip</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    writeResult<span class=\"token operator\">=</span>result<span class=\"token punctuation\">.</span><span class=\"token function\">write</span><span class=\"token punctuation\">(</span>buffer<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ExecutionException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">TimeoutException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span><span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">try</span><span class=\"token punctuation\">{</span>\n                        server<span class=\"token punctuation\">.</span><span class=\"token function\">accept</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        writeResult<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                        result<span class=\"token punctuation\">.</span><span class=\"token function\">close</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">ExecutionException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">InterruptedException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">IOException</span> e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                        <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">RuntimeException</span><span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span>\n                <span class=\"token punctuation\">}</span>\n            <span class=\"token punctuation\">}</span>\n\n            <span class=\"token annotation punctuation\">@Override</span>\n            <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">failed</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Throwable</span> exc<span class=\"token punctuation\">,</span> <span class=\"token class-name\">Object</span> attachment<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"failed:\"</span><span class=\"token operator\">+</span>exc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n</code></pre>\n"},{"type":"ordered_list","depth":3,"payload":{"lines":[514,516],"startIndex":1},"content":"","children":[{"type":"list_item","depth":4,"payload":{"lines":[514,515],"index":1},"content":"1. 发起accept请求,<strong>告诉系统可以开始监听端口</strong>。"},{"type":"list_item","depth":4,"payload":{"lines":[515,516],"index":2},"content":"2. 注册CompletionHandler实例,告诉系统一旦有客户端连接,如果成功连接,就去执行CompletionHandler.completed()方法;如果连接失败,就去执行CompletionHandler.failed()方法"}]}]}]}],"payload":{}},{})</script>
</body>
</html>
