之前读书和实践的时候还是很青涩,前置知识铺垫的也不够,现在回过头来将之前的笔记整理一下。如果有可能,我希望能有一个good ending。。。
## 并发的基础
操作系统进程 资源分配的基本单位
和线程 调度的基本单位
一个进程中会有多个线程，这些线程会共享进程的内存空间、文件句柄等
**相比串行并发更加具有处理多任务的优势**
等水烧开的时候可以去干其他事儿
## 简单的模型
servlet  
多个请求来访问servlet的时候，**阻塞I/O暴露的问题就是必须得等待**，那么我们必须使用**非阻塞I/O，同时由于操作系统中一个进程下可能只允许创建数个线程**
#### select和poll多路复用
## 应用
Timer-定时任务处理，我们Timer类有可能访问应用程序中的数据，那么我们就得以线程安全的方式去访问应用程序的数据，那么其他访问应用程序也应当是线程安全的，所以这个时候最简单的方式就是直接将访问的对象应用为线程安全的。
Servelt(JSP)-试想一下这样的一个场景，有可能我们会遇到多个请求去访问同一个Servlet，或者是一个Servlet去访问多个Servlet中的多个线程，那么如何保证安全，这也是我们必须所考虑的
**RMI-romote method invocation远程调用**:我们有可能去远程调用JVM中的方法，调用的是哪个方法我们不知道，调用的是哪个线程，有没有可能调用多个线程，这些都是我们必须所考虑的问题
预备知识
内存屏障
[链接1](http://ifeve.com/memory-barriers-or-fences/)
[链接2](https://www.jianshu.com/p/2ab5e3d7e510)
## 线程的安全性
线程安全性，就是对象中有状态变量的时候，如果多个线程进行访问的话那么有可能不安全。
## 原子性
最简单的例子就是自增操作，i++的操作分为3步：
1.取i的值
2.在i原来的值的基础上进行自增操作
3.对i的值进行更新
上述的每一步都是原子性的，但是操作系统中有指令重排序(后面会进行学习)，当然在此我们需要保证整个操作的原子性。
**竞态条件 延迟初始化中的竞态条件**
#### 单例模式中对象的创建
#### 复合操作
## 加锁机制
#### 内置锁
jdk中的内置锁(监视器锁)，每个对象都含有一个内置锁，我的理解是线程会与对象内置锁进行关联。
#### 重入锁
## 用锁来保护状态
最简单的例子就是Servlet，当多个用户进行请求读取缓存中值的时候，那么我们就需要保证**程序的值和内存中的值的一致性**。
## 活跃与性能
还是用Servlet来进行说明，当多个用户访问时，如果使用了synchronzied关键字的话，不可避免会将除当前线程外的其他线程进行阻塞，这时程序的响应性能就非常低了。
## 可见性
当读写操作串行时，那么变量的值是一定的。但如果当读写操作不在同一个线程中，而在不同的线程中，那么就无法保证读线程对于内存写入操作的可见性。  
```java
public class Novisibility{
	private static boolean ready;
    private static int number;
    
    private static class ReadThread extends Thread{
    	public void run(){
        	while(!ready){
            	Thread.yeild();
                System.out.println(number);
            }
        }
    }
    
    public static void main(String[] args){
    	ready=true;
        number=42;
    }
}、
```
由于没有使用同步机制，对于读线程来说，主线程中值的更新对于读线程来说不一定是可见的。  
两种现象，一种是读线程可能永远也看不到ready的值；  
另外一种是读线程虽然能够访问到ready的值，但是number的值却有可能为0，为什么，如果我们没有使用同步机制，操作系统中就会进行指令重排序，从而导致读线程读到的可能与写线程写入的顺序相反。  
### 失效数据
a线程和b线程，当访问没有进行同步时，假设一个线程进行的是读操作，另一个操作进行的是写操作，如果无法进行同步的话，读线程可能访问的是更新之前的值，也可能访问的是更新之后的值。  
### 非原子的64位操作
jvm中，允许将一个long类型的64位的数据以两个32位的数据进行保存，如果多个线程进行访问的话，可能的结果就是拿到了原来的比如说低32位的数据和更新后的高32位的操作，那么这个时候显然变量的安全性无法保障  
### 加锁和可见性的保证
Java中的内置锁，当a线程和b线程访问同一个同步代码块，b线程在lock之前能够看到a线程的unlock之前额所有操作结果实现了同步的可见性保。  
我的理解是：  
jdk提供的内置锁，可以将一个对象中的某个代码同步起来，什么意思呢，多个线程访问的时候，某个线程对象的监视器锁进行绑定，只有当前线程释放锁之后，其他线程才可访问同步代码块，不然会处于阻塞（or其他形式？？？） 
还有书上提到了要求在同一个锁中，前面的学习可知，Java中每个对象含有一个内置锁，也就是说多个线程访问的是同一个对象？？？？？？  
## 发布与逸出
发布：“发布”一个对象的意思是指，是对象能够在当前的作用域之外的代码中去使用。例如，将一个指向该对象的引用保存到其他代码可以访问的地方，或者在某一个非私有的方法中返回引用，或者将引用传递到其他类的方法中。我们有可能不想对象被发布，也可能需要发布对象。  
发布对象的最简单方法是将对象的引用保存到一个公有的静态变量中，以便任何类和线程都能看见该对象。  
```java
public static Set<Secret> knowSecrets; //定义一个static的变量
public void initiaize(){
	knowSecrets=new HashSet<Secret>();  //将HashSet对象的引用保存到knowSecret中
}
```
逸出：虽然书上没有提到，我的理解就是本不该被发布的内容由于代码的不规范而被发布了，可惜我平时的crud中似乎从来没考虑过这个问题。当发布一个对象时，在该对象的非私有域中中引用的所有对象同样会被发布。一般来说，如果一个已经发布的对象能够通过非私有的变量引用和方法调用到达其他的对象，那么这些对象那个也都会被发布。  
还有种发布对象或者其内部状态的机制就是发布一个内部的实例

```java
public class ThisEscape{
	public ThisEscape(EvnetEscape source){xiancheng
    	source.registerListener(new EventListener(){
        	public void onEvent(Event e){
            	doSomething(e);
            }
        });
    }
}
```

### 安全的对象构造

通过上述内容，我们可知，当内部实例发布时，外部封装的实例(ThisEscape)实例也逸出了，“当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态。”也就是说，当从一个对象的构造函数中发布对象时，发布了一个尚未完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确的构造，我们应该避免在构造过程中是this逸出。
常见的错误是，在构造函数中启动一个线程。当对象在其构造函数中创意建一个线程时，无论是显式创建(通过将它传给构造函数)还是隐式创建(由于Thread或Runnable是是该对象的一个内部类)，this引用都会被新创建的线程共享。在未完全构造前，新的线程就可以看见他，所以他就不符合安全构造对象的规范。
在构造函数中创建线程并没有错误，但不要立即启动他，而是通过一个start或者initialize方法来启动。
如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法，从而避免不正确的构造过程。

```java
public class SafeListener{
	private final EventListener listener;
    
    private SafeListener(){
    	listener=new EventListener(){
        	public void onEvent(Event e){
            	doSomething(e);
            }
        };
    }
    
    public static SafeListener newInstance(EventSource source){
    	SafeListener safe=new SafeListener();
        source.registerListener(safe.listener);
        return safe;
    }
}
```
## 线程封闭
当访问共享的可变数据时，通常需要同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭(Thread Confinement),它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。
线程封闭技术的一种常见应用是JDBC(Java Database Connectivity)的Connection对象。JDBC规范并不要求Connection对象必须是线程安全的。在典型的服务器应用程序中，线程从连接池中获得一个Connection对象，并且用该对象来处理请求，使用完之后再将对象返还给连接池。由于大多数请求(例如Servlet请求或EJB调用等)都是单个线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会再将它分配给其他线程。
### Ad-hoc线程封闭
维护线程封闭的职责完全由程序实现来承担。
### 栈封闭
栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。可以和封装进行一个类比，封装使得代码更容易维持代码的不变性，同步变量也能使对象更易于封闭在线程中。局部变量的固有属性之一就是封闭在执行线程中。他们位于执行线程的栈中，其他线程无法访问这个栈。
```java
public int loadTheArk(Collection<Animal> candidates){
	SortedSet<Animal> animals;
    int numPairs=0;
    Animal candidate=null;
    
    animal=new TreeSet<Animal>(new SpeciesGenderComparator());
    animals.addAll(candidates);
    for(Animal a:animals){
    	if(candidate==null || !candidate.isPotentialMate(a)){
        	candidte=a;
        }else {
        	ark.load(new AnimalPair(candidate,a));
            ++numPairs;
            candidate=null;
        }
    }
    return numPairs;
}
```
我的理解：
猜想和深入理解JVM中提到的每个方法都有自己的栈有关
“局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中”，当前执行线程有栈，栈里面有每个方法的变量和返回值等，也就是说局部变量只能由当前线程进行访问，其实也就是线程封闭的一种。但是如果发布了对集合animals(或者该对象中的任何内部数据)的引用，那么封闭性将被破坏，并导致对象animals的逸出。

### ThreadLocal类

为每个线程保留了一个当前线程访问的副本，并将其与原对象进行关联，提供了get与set等接口或方法，这些方法。
ThreadLocal对象通常用于防止对可变的单实例变量(Singleton)或全局变量进行共享。例如，在单线程应用程序中可能会维持一个全局的数据库连接。并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都要传递一个Connection对象。由于JDBC的连接对象不是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会有一个属于自己的连接对象。

```java
private static ThreadLocal<Connection> connectionHolder=new ThreadLocal<Connection>(){
	public Connection initialValue(){
    	return DriverManager.getConnection(DB_URL);
    }
};

public static Connection getConnection(){
	return connectionHolder.getConnection();
}
```
ThreadLocal<Connction>指定了我在ThreadLocal中保存的是Connection类型的对象，由Java核心技术卷可知，泛型的定义是从编译器角度出发的。写了自定义类之后，我们在其内部定义了initialValue方法来帮助我们获得连接。
当某个执行频繁的操作需要一个临时对象，例如，Java5.0之前，Integer.toString()方法使用ThredLocal对象来保存一个12字节大小的缓冲区，而不是使用共享的静态缓冲区(这需要使用锁机制)或者在每次调用时都分配一个新的缓冲区。
“从概念上看，你可以将ThreadLocal<T>视为包含了Map<Thread,T>对象，其中保存了特定位于该线程的值...这些特定于线程的值保存在Thread对象中，当线程终止后，这些值将会作为垃圾回收。”
在实现应用程序框架时大量使用了ThreadLocal。例如，在EJB调用期间，J2EE容器需要将一个事务上下文(Transaction Context)与某个执行中的线程关联起来。通过将事务上下文保存在静态的ThreadLocal对象中，可以很容易实现这个功能:当框架代码需要判断当前运行的是哪个事务时，只需要从这个ThreadLocal对象中读物事务上下文。

## 不变性

如果某个对象在被创建后其状态就不能被修改，那么这个对象被称为不可变对象。线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的，只要他们不改变，那么这些不变性条件就会维持。

```java
@Immutable
public final class ThreeStooges{
	private final Set<String> stooges=new HashSet<String>();
    
    public ThreeStooges(){
    	stooges.add("Moe");
        stooges.add("Larry");
        stooges.add("Curly");
    }
    
    public boolean isStooge(String name){
    	return stooges.contains(name);
    }
}
```
类ThreeStooges中定义了一个可变的Set对象，但是用的final类型来声明变量类型，所以Set对象构造完成之后无法进行修改。而ThreeStooges构造函数也很明确add了三个对象，也就是说后面不会再进行修改
### Fina域
Java核心技术卷中提到的final关键字，其实也就是final域，个人猜想也是Java的机制之一。
### 示例：使用volatile类型来发布不可变对象
“对于在访问和更新多个相关变量出现的竞争条件问题，可以通过将这些变量全部保存到一个不可变对象中来消除。”在第二章中，我们有遇到过创建对象getInstance()时判断Object是否存在的竞态条件，如果将这需要进行判断的对象设置为不可变的话，其实竞态也就不存在，因为不可变对象从一开始就设置好了状态，后面肯定不会修改。
“如果要更新这些变量，那么可以创建一个新的容器对象，但其他使用原有对象的线程依然会看到对象处于一致的状态”，VolatileCachedFactorizer使用了OneValueCache来保存缓存的数值及其因数。“当一个线程将volatile类型的cache设置为引用一个新的OneValueCache时”，其他线程就能立即看到新缓存的数据。

```java
@ThreadSafe
public class VolatileCachedFactorizer implements Servlet{
	private volatile OneValueCache cache=new OneValueCache(null,null);
    
    public void service(ServletRequest req,ServletResponse resp){
    	BigInteger i=extracrFromRequest(req);
        BigInteger[] factors=cache.getFactors(i);
        if(factors==null){
        	factors=factor(i);
            cache=new OneValueCache(i,factors);
        }
        encodeIntoResponse(resp,factors);
    }
}
```
## 安全发布
最常见的发布方式就是将对象引用保存到公有域中
```java
//不安全的发布
public Holder holder;

public void intialize(){
	holder=new Holder(42);
}
```
由于可见性问题，其他线程看到的Holder对象将会处于不一致的状态，线程之间不可见的话，那么a线程无法看到b线程是否保存了b线程的引用，即便在该对象的构造函数中已经正确地创建了不变性条件，这种不正确的发布导致其他线程看到尚未创建完成的对象。 
### 不能正确的发布：正确的对象被破坏
由于没有使用同步来确保Holder对象对其他线程可见，因此将Holder称为“未被正确发布”。存在两个问题，首先，除了发布Holder对象的线程之外，其他线程看到的Holder域是一个失效值，因此将看到一个空引用或者之前的失效值；更糟糕的是线程看到的Holder引用的值是最新的，但Holder状态的值却是失效的。  某个线程在第一次读取域时得到失效值，而再次读取这个域时会得到一个更新值。  
### 不可变对象与初始化安全性
“任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。”  
这种保证还将延伸到被正确创建的对象中所有final类型的域。  
在没有额外同步的情况下，也可以安全地访问final类型的域。  
然后，如果final类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时任然需要同步。  
### 安全发布的常用模式
可变对象必须通过安全的方式来发布，这通常意味着在发布和使用该对象的线程时都必须使用同步。  
"要安全地发布一个对象，对象的引用以及对对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全地发布："  
在静态初始化函数中初始化一个对象引用  
将对象的引用保存到volatile类型的域或者AtomicReferance对象中。  
将对象的引用保存到某个正确构造对象的final域中。  
将对象的引用保存到一个由锁保护的线程中。  
在线程安全容器内部的同步意味着，在将独享放入到某个容器，例如Vector或synchronizedList时，将满足上述最后一条需求。如果线程A将对象X放入一个线程安全的容器，随后线程B读取这个对象，那么可以确保B看到A设置的X状态，即便在这段读/写X的应用程序代码中没有包含显式的同步  
通过将一个键或者值放入Hashtable、synchronizedMap或者 ConcurrentMap中，可以安全地将它发布给任何从这些容器中访问它的线程(无论是直接访问还是通过迭代器访问)
通过将某个元素放入Vector、CopyOnWriteArrayList、CopyOnWriteArraySet、synchronizedList或者synchronizedSet中，可以将该元素安全地发布到任何从这些容器中访问该元素的线程  
通过将某个元素放入BlockingQueue或者ConcurrentLinkedQueue中，可以将该元素安全地发布到任何从这些队列中访问该元素的线程  
### 事实不可变对象  
如果对象从技术上来看是可变的，但其状态在发布后不会再改变没那么把这种对象称为“事实不可变对象”。  
```java
public Map<String,Date> lastLogin=Collections.synchronizedMap(new HashMap<String,Date>());
```
### 可变对象
要安全地共享可变对象，这些对象就必须被安全地发布  
对象的发布需求取决于它的可变性  
不可变对象可以通过任意机制来发布  
事实不可变对象必须通过安全方式来发布  
可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。 
### 安全地共享对象
当发布一个对象时，必须明确地说明对象的访问方式  
线程封闭 前面提过  
只读共享 表面意思  
线程安全共享 内部实现同步  
保护对象 被保护的对象只能通过持有特定的锁来访问  
## 对象的组合
我们并不希望每一次对内存访问都行分析以确保内存以确保程序是线程安全的，而是希望将一些现有的线程组合为更大规模的组件或程序。  
一些概念：  
不变约束：不变式表达了对状态的约束，这些状态是应该符合这个约束的值的组合。不变式可以代表某种业务规则。  
先验条件：针对方法，规定了在条用方法之前必须为真的条件  
后验条件：针对方法，规定了在条用方法之后必须为真的条件  
### 4.1 设计线程安全的类
在线程安全的程序中，虽然可以将程序的素有状态都保存在公有的静态域中，但与那些将状态封存起来的程序相比，这些程序的安全性更难以得到保证，并且在修改时也更难以始终确保其线程安全性。  
如何判断一个线程是安全的，我们通过三要素来设计线程安全类  
1.找出构成对象状态的所有变量  
2.找出约束状态变量的不变性条件  
3.家里对象状态的并发访问管理策略  
我们先来分析一下对象的状态，首先从对象的域开始。如果对象中所有的域都是基本类型的变量，那么这些域就是构成对象的全部状态。下面这段代码中只有一个域value，因此这就是Counter的全部状态。对于含有n个基本类型的对象，其状态就是这些域构成的n元组。**如果在对象的域中引用了其他对象，那么该对象域的状态将包含被引用对象的域。**例如，LinkedList的状态就包括该链表中所有节点对象的状态。  
```java
@ThreadSafe
public final class Counter{
@GuardedBy("this") private long value=0;

public syschronized long getValue(){
return value;
}

public syschronized long increment(){
if(value==Long.MAX_VALUE){
throw new IllegalStateException("counter overflow");
return ++value;
}
}
}
```
同步策略定义了如何在**不违背对象不变性条件或后验条件的情况对其状态的访问操作进行协同。同步策略还规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量有哪些锁来保护。**  
#### 4.1.1 收集同步需求
要确保类的线程安全性，就是要确保对类的不变性条件不能发生改变，那么就得判断类的状态。**对象和变量都有一个状态空间，即所有可能的取值。**状态空间越小，就越容易判断线程的状态。例如，上面的代码中我们使用了long类型的value域，它的取值范围是Long.MIN_VALUE到Long.MAX_VALUE，但是不能为负值。同样，还会有一些后验条件来判断对象的状态迁移是否为有效的。例如当前状态为17，那么下一个就只能为18。当下一个状态需要依赖当前的状态时，这个操作就必须得是一个复合操作。但并不是所有的状态迁移操作都要加限制。  
由于不变性条件(对象被构建之后状态就不能发生改变)和后验条件在状态转换上添加了各种约束，因此就需要额外的同步与封装。**如果某些状态是无效的，那么必须在底层对状态变量进行封装，否则客户端代码可能使对象处于无效状态。如果在某个操作中存在无效的状态转换，那么该操作必须是原子的。**  
在类中可以同时包含多个约束状态变量的不变性条件。在一个表示数值范围的类NumberRange中可以包含两个状态变量，分别表示范围的上界和下界。必须遵循的约束是,下界值应该小于或等于上界值。那么这种多个变量不变性条件马上带来了原子性需求:**这些相关的变量访问或者更新必须在某个单个原子操作中执行。不能首先更新一个变量，然后释放锁并再次获得锁，然后再次更新其他的变量**。因为释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。  
#### 4.1.2 依赖状态的操作
类的不变性条件和后验条件约束了在对象中有哪些状态和状态转换是有效的。在某些对象的方法中，还包含一些基于状态的先验条件，例如，空队列中如果没有元素时，那么就不允许删除操作。在单线程中，先验条件不满足就gg，但是并发程序中，有可能因为其他线程执行的操作而使得先验条件变成真，所以并发程序中要等到先验条件为真再执行操作。
在Java中，等待某些条件为真与内置锁的紧密相关，想要正确地使用还是比较困难的。

###### 4.1.3 状态的所有权

在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据。所有权(ownership)在Java中并没有得到充分的体现，而是属于类设计中的一个要素。如果类中分配并填充了一个HashMap对象，那么就相当于创建了多个对象:HashMap对象，在HashMap对象中包含的多个对象，以及在Map.Entry中可能包含的多个对象。HashMap对象的逻辑状态包括所有的Map.Entry对象以及内部对象，即使这些对象都是一些独立的对象。  
当把一个对象传递给某个方法时，我们必须考虑对象所有权的问题，Java和C++一样，存在所有权模型，只不过垃圾回收器为我们减少了许多在引用共享方面常见的错误，因此降低了在所有权处理上的开销。  
许多情况下，所有权与封装性总是相互关联的:对象封装它拥有的状态，反之也成立。即对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁机制协议来维持变量状态的完整性。所有权意味着控制权。然而，**如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是“共享控制权”。**对于从构造函数或者方法中转移进来的对象，类通常拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权(例如，同步容器封装器的工厂方法)
容器类通常表现出一种“所有权分离”的形式，**其中容器类拥有其自身的状态，而客户代码拥有容器中各个对象的状态。**Servlet框架中的ServletContext就是其中一个示例，ServletContext为Servlet提供了类似于Map形式的对象容器服务，在ServletContext中通过名称来注册(setAttribute)或获取(getAttribute)应用程序对象。由Servlet容器创建的ServletContext对象必须是线程安全的，因为它肯定会被多个线程访问。当调用setAtrribute和getAttribute时，Servlet不需要使用同步，但当使用保存在ServletContext中的对象，则可能需要使用同步。这些对象由应用程序拥有，Servlet容器只是替应用保存他们。所有共享对象一样，他们必须安全地被共享。**为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程安全的对象，要么是事实不可变对象，或者由锁来保护的对象。**  
### 4.2 实例封闭
如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。  
封装简化了线程安全类的实现过程，它提供了一种实例封闭机制(Instance Confinement),通常也称为"封闭"。当一个对象被封装到另一个对象中时，能够访问被封装对象的**所有代码路径**都是已知的。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。**将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。**  
### 4.3 线程安全性的委托
### 4.4 在现有的线程安全类中添加功能
### 4.5 将同步策略文档化
## 容器
这本书可能生怕你读不懂,所以前面4章列举了大量的例子来帮助你直观地感受多线程的妙用和带来的一系列问题,相比之下高并发程序设计这本书就比较直接了当一些,所以我站高并发程序设计。
### 并发同步容器
JDK中最早的同步容器类有HashTable和Vector,但是在进行某些复合操作时还是无法保证线程安全。
常用的集合类都有对应的同步安全类
List CopyOnWriteArrayList
Map ConcurrentHashMap
Queue比较特殊,可能平时开发过程中见的比较少,但是这是一个接口,它的实现类大家一定都不陌生就是LinkedList
BlockingQueue扩展了Queue，是从线程安全的角度
#### ConcurrentHashMap
书上描述的还是分段锁,但是1.8之后变为了链表桶的头节点加锁
#### CopyOnWriteArrayList
写入时复制 每次修改时都会创建并重新发布一个**新的容器副本**从而实现可变性  
容器中的迭代器会保留一个指向底层数组的引用,这个数组当前位于迭代器的其位置,它不会被修改(???),对其进行同步时只需要确保内容的可见性(访问主存中的变量???),多个线程可以同时对其进行迭代或者与修改的线程不会彼此干扰???
#### 生产者和消费者模式
##### 阻塞队列
BlockingQueue,提供了offer和poll方法,与queue相比的话,如果操作阻塞那么会返回一个**失败状态**  
##### 阻塞双端队列
Deque
###### 工作密取设计模式
不同于生产者消费者模式，多个线程去消费队列中的数据，不只是自己的任务队列
#### 同步工具类
##### CountDownLatch
说到这里，我讲一下自己工作中遇到的使用场景吧
### 任务执行
这一章从一个WebServer的角度来讲解多线程对于任务处理的流程  
书上的例子先是阻塞处理请求、为每个请求创建单独线程再到引出Executor框架，但是我感觉它反而对于Executor没有表述清楚  
#### Executor接口
书上的描述是异步任务执行框架的基础
### 线程的中断和取消
#### 中断和取消
**常用API**
#### Future取消任务
#### Executor取消任务