# Java并发编程学习记录4-对象的组合
我们并不希望每一次对内存访问都行分析以确保内存以确保程序是线程安全的，而是希望将一些现有的线程组合为更大规模的组件或程序。  
一些概念：  
不变约束：不变式表达了对状态的约束，这些状态是应该符合这个约束的值的组合。不变式可以代表某种业务规则。  
先验条件：针对方法，规定了在条用方法之前必须为真的条件  
后验条件：针对方法，规定了在条用方法之后必须为真的条件  
## 4.1 设计线程安全的类
在线程安全的程序中，虽然可以将程序的素有状态都保存在公有的静态域中，但与那些将状态封存起来的程序相比，这些程序的安全性更难以得到保证，并且在修改时也更难以始终确保其线程安全性。  
如何判断一个线程是安全的，我们通过三要素来设计线程安全类  
1.找出构成对象状态的所有变量  
2.找出约束状态变量的不变性条件  
3.家里对象状态的并发访问管理策略  
我们先来分析一下对象的状态，首先从对象的域开始。如果对象中所有的域都是基本类型的变量，那么这些域就是构成对象的全部状态。下面这段代码中只有一个域value，因此这就是Counter的全部状态。对于含有n个基本类型的对象，其状态就是这些域构成的n元组。**如果在对象的域中引用了其他对象，那么该对象域的状态将包含被引用对象的域。**例如，LinkedList的状态就包括该链表中所有节点对象的状态。  
```java
@ThreadSafe
public final class Counter{
@GuardedBy("this") private long value=0;

public syschronized long getValue(){
return value;
}

public syschronized long increment(){
if(value==Long.MAX_VALUE){
throw new IllegalStateException("counter overflow");
return ++value;
}
}
}
```
同步策略定义了如何在**不违背对象不变性条件或后验条件的情况对其状态的访问操作进行协同。同步策略还规定了如何将不可变性、线程封闭与加锁机制等结合起来以维护线程的安全性，并且还规定了哪些变量有哪些锁来保护。**  
### 4.1.1 收集同步需求
要确保类的线程安全性，就是要确保对类的不变性条件不能发生改变，那么就得判断类的状态。**对象和变量都有一个状态空间，即所有可能的取值。**状态空间越小，就越容易判断线程的状态。例如，上面的代码中我们使用了long类型的value域，它的取值范围是Long.MIN_VALUE到Long.MAX_VALUE，但是不能为负值。同样，还会有一些后验条件来判断对象的状态迁移是否为有效的。例如当前状态为17，那么下一个就只能为18。当下一个状态需要依赖当前的状态时，这个操作就必须得是一个复合操作。但并不是所有的状态迁移操作都要加限制。  
由于不变性条件(对象被构建之后状态就不能发生改变)和后验条件在状态转换上添加了各种约束，因此就需要额外的同步与封装。**如果某些状态是无效的，那么必须在底层对状态变量进行封装，否则客户端代码可能使对象处于无效状态。如果在某个操作中存在无效的状态转换，那么该操作必须是原子的。**  
在类中可以同时包含多个约束状态变量的不变性条件。在一个表示数值范围的类NumberRange中可以包含两个状态变量，分别表示范围的上界和下界。必须遵循的约束是,下界值应该小于或等于上界值。那么这种多个变量不变性条件马上带来了原子性需求:**这些相关的变量访问或者更新必须在某个单个原子操作中执行。不能首先更新一个变量，然后释放锁并再次获得锁，然后再次更新其他的变量**。因为释放锁后，可能会使对象处于无效状态。如果在一个不变性条件中包含多个变量，那么在执行任何访问相关变量的操作时，都必须持有保护这些变量的锁。  
### 4.1.2 依赖状态的操作
类的不变性条件和后验条件约束了在对象中有哪些状态和状态转换是有效的。在某些对象的方法中，还包含一些基于状态的先验条件，例如，空队列中如果没有元素时，那么就不允许删除操作。在单线程中，先验条件不满足就gg，但是并发程序中，有可能因为其他线程执行的操作而使得先验条件变成真，所以并发程序中要等到先验条件为真再执行操作。
在Java中，等待某些条件为真与内置锁的紧密相关，想要正确地使用还是比较困难的。

### 4.1.3 状态的所有权

在定义哪些变量将构成对象的状态时，只考虑对象拥有的数据。所有权(ownership)在Java中并没有得到充分的体现，而是属于类设计中的一个要素。如果类中分配并填充了一个HashMap对象，那么就相当于创建了多个对象:HashMap对象，在HashMap对象中包含的多个对象，以及在Map.Entry中可能包含的多个对象。HashMap对象的逻辑状态包括所有的Map.Entry对象以及内部对象，即使这些对象都是一些独立的对象。  
当把一个对象传递给某个方法时，我们必须考虑对象所有权的问题，Java和C++一样，存在所有权模型，只不过垃圾回收器为我们减少了许多在引用共享方面常见的错误，因此降低了在所有权处理上的开销。  
许多情况下，所有权与封装性总是相互关联的:对象封装它拥有的状态，反之也成立。即对它封装的状态拥有所有权。状态变量的所有者将决定采用何种加锁机制协议来维持变量状态的完整性。所有权意味着控制权。然而，**如果发布了某个可变对象的引用，那么就不再拥有独占的控制权，最多是“共享控制权”。**对于从构造函数或者方法中转移进来的对象，类通常拥有这些对象，除非这些方法是被专门设计为转移传递进来的对象的所有权(例如，同步容器封装器的工厂方法)
容器类通常表现出一种“所有权分离”的形式，**其中容器类拥有其自身的状态，而客户代码拥有容器中各个对象的状态。**Servlet框架中的ServletContext就是其中一个示例，ServletContext为Servlet提供了类似于Map形式的对象容器服务，在ServletContext中通过名称来注册(setAttribute)或获取(getAttribute)应用程序对象。由Servlet容器创建的ServletContext对象必须是线程安全的，因为它肯定会被多个线程访问。当调用setAtrribute和getAttribute时，Servlet不需要使用同步，但当使用保存在ServletContext中的对象，则可能需要使用同步。这些对象由应用程序拥有，Servlet容器只是替应用保存他们。所有共享对象一样，他们必须安全地被共享。**为了防止多个线程在并发访问同一个对象时产生的相互干扰，这些对象应该要么是线程安全的对象，要么是事实不可变对象，或者由锁来保护的对象。**  
## 4.2 实例封闭
如果某对象不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。  
封装简化了线程安全类的实现过程，它提供了一种实例封闭机制(Instance Confinement),通常也称为"封闭"。当一个对象被封装到另一个对象中时，能够访问被封装对象的**所有代码路径**都是已知的。与对象可以由整个程序访问的情况相比，更易于对代码进行分析。通过将封闭机制与合适的加锁策略结合起来，可以确保以线程安全的方式来使用非线程安全的对象。**将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。**  
## 4.3 线程安全性的委托
## 4.4 在现有的线程安全类中添加功能
## 4.5 将同步策略文档化