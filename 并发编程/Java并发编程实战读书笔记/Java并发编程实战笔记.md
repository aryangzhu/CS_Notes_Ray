**写在前面**
这本书可能生怕你读不懂,所以前面4章列举了大量的例子来帮助你直观地感受多线程的妙用和带来的一系列问题,相比之下高并发程序设计这本书就比较直接了当一些,所以我站高并发程序设计。
### 并发同步容器
JDK中最早的同步容器类有HashTable和Vector,但是在进行某些复合操作时还是无法保证线程安全。
常用的集合类都有对应的同步安全类
List CopyOnWriteArrayList
Map ConcurrentHashMap
Queue比较特殊,可能平时开发过程中见的比较少,但是这是一个接口,它的实现类大家一定都不陌生就是LinkedList
BlockingQueue扩展了Queue，是从线程安全的角度
#### ConcurrentHashMap
书上描述的还是分段锁,但是1.8之后变为了链表桶的头节点加锁
#### CopyOnWriteArrayList
写入时复制 每次修改时都会创建并重新发布一个**新的容器副本**从而实现可变性  
容器中的迭代器会保留一个指向底层数组的引用,这个数组当前位于迭代器的其位置,它不会被修改(???),对其进行同步时只需要确保内容的可见性(访问主存中的变量???),多个线程可以同时对其进行迭代或者与修改的线程不会彼此干扰???
#### 生产者和消费者模式
##### 阻塞队列
BlockingQueue,提供了offer和poll方法,与queue相比的话,如果操作阻塞那么会返回一个**失败状态**  
##### 阻塞双端队列
Deque
###### 工作密取设计模式
不同于生产者消费者模式，多个线程去消费队列中的数据，不只是自己的任务队列
#### 同步工具类
##### CountDownLatch
说到这里，我讲一下自己工作中遇到的使用场景吧
### 任务执行
这一章从一个WebServer的角度来讲解多线程对于任务处理的流程  
书上的例子先是阻塞处理请求、为每个请求创建单独线程再到引出Executor框架，但是我感觉它反而对于Executor没有表述清楚  
#### Executor接口
书上的描述是异步任务执行框架的基础
### 线程的中断和取消
#### 中断和取消
**常用API**
#### Future取消任务
#### Executor取消任务