**写在前面**
这本书可能生怕你读不懂,所以前面4章列举了大量的例子来帮助你直观地感受多线程的妙用和带来的一系列问题,相比之下高并发程序设计这本书就比较直接了当一些,所以我站高并发程序设计。
# 并发同步容器
JDK中最早的同步容器类有HashTable和Vector,但是在进行某些复合操作时还是无法保证线程安全。
常用的集合类都有对应的同步安全类
List CopyOnWriteArrayList
Map ConcurrentHashMap
Queue比较特殊,可能平时开发过程中见的比较少,但是这是一个接口,它的实现类大家一定都不陌生就是LinkedList
BlockingQueue扩展了Queue
## ConcurrentHashMap
书上描述的还是分段锁,但是1.8之后变为了链表桶的头节点加锁
## CopyOnWriteArrayList
写入时复制 每次修改时都会创建并重新发布一个**新的容器副本**从而实现可变性  
容器中的迭代器会保留一个指向底层数组的引用,这个数组当前位于迭代器的其位置,它不会被修改(???),对其进行同步时只需要确保内容的可见性(访问主存中的变量???),多个线程可以同时对其进行迭代或者与修改的线程不会彼此干扰???
## 生产者和消费者模式
### 阻塞队列
BlockingQueue,提供了offer和poll方法,与queue相比的话,如果操作阻塞那么会返回一个失败状态  
### 阻塞双端队列
Deque
#### 工作密取设计模式
## 同步工具类
### CountDownLatch
说到这里，我讲一下自己工作中遇到的使用场景吧
有个获取证书的任务