# 第一章 走入并行
## 必须知道的几个概念
### 同步和异步
同步:串行执行，必须得等前面的执行完以后后面的任务才能执行。  
异步:调用方法后立即返回，然后调用者可以立即执行后面的任务，而等被调用的方法完成之后会通知调用者。
### 并发与并行
并发:短时间内还是串行。  
并行:真正意义上的同时执行。  
### 临界区
多个线程共享的公共资源或者是共享数据。每一次只能有一个线程占用。  
### 阻塞与非阻塞
阻塞:如果其他线程占用了临界区资源，那么当前线程会在临界区挂起,这种情况称为阻塞。 
### 死锁、饥饿、活锁
#### 死锁
死锁:如果多个线程循环等待,那么就会出现死锁。  
死锁产生的三个条件:  
1.互斥条件：同一资源同一时刻只能被一个线程占有。  
2.请求与保持条件：拿到了资源以后,如果因为请求资源而阻塞,那么就会持有资源不释放。  
3.不可剥夺条件:资源在被一个线程拿走之后，其他线程就不能剥夺这个线程的资源。  
4.循环等待条件:线程之间会等待其他线程的资源从而形成一个等待循环。  
破坏死锁:  
1.破坏请求与保持条件:一次性申请所有资源。  
2.破坏不可剥夺条件:占用部分资源的线程去申请其他资源，如果申请不到的话那么就释放掉持有的资源。  
3.破坏循环等待条件:按序申请资源,资源反序释放。这样就能保证一个线程从头到尾获得资源。
#### 饥饿
某一线程或者多个线程以为请求不到资源导致一直无法运行(猜测是以时间来判断???),比如因为线程优先级过低，一直有高优先级线程执行。  
#### 活锁 
活锁则是因为过于“谦让“而导致线程无法拿到全部资源。想象的场景是:两个人不停为对方让路。 
## 并发级别
### 阻塞
采用的是悲观策略。
### 无饥饿
尽量采用公平的线程队列，好让所有线程都能够有机会执行。  
### 无障碍
首先是一种乐观的策略,所有线程都可以进入临界区,当多个线程共同修改数据而导致数据破坏时会采用**回滚**策略(侧面也可以看出这种级别认为不会有过多的线程同时修改资源导致并发问题)。  
可行的无障碍实现是依赖一个"一致性标记"来实现。线程在操作之前,先读取并保存这个标记,在操作完成以后,再次读取，检查这个标记是否被修改过。  
### 无锁
无锁是无障碍的。  
无锁会有多个线程在临界区内修改资源,但是总有一个会成功???  
### 无等待
无等待要求线程在有限步内完成操作,这样不会引起饥饿问题(饥饿就是因为一直不执行)。  
典型的无等待结构RCU (Read-Copy-Update)。它的基本思想是,对数据的读不加修改。因此,所有的线程都是无等待的,它们既不会被锁定等待也不会引起任何冲突。
## 并行有关的两个定律
### Amdahal定律
### Gustafson定律
## 回到Java:JMM
JMM:Java内存模型(和JVM关注的点不一样)。由于Java并发的复杂性,所以导致了线程不安全的问题,如何保证下面这些特性也是我们关注的重点:
### 原子性(Atomicity)
指的是一个操作还没完成前,其他线程无法干扰。如果Java虚拟机是32位的话,那么long类型的变量赋值就有可能发生问题(因为long类型是64位,我猜测需要两个线程来完成赋值操作???),所以就会导致值和预期不一致的情况。
### 可见性(Visibility)
如果在一个线程中修改了某个变量的值,其他共享的线程是否知道。一般来说,其他线程观察当前线程(是否观察到、何时观察到)是无法保证的。
### 有序性(Ordering)
按照书上的说法来说,干扰有序性的主要因素就是指令重排。指令重排出现的问题就是减少操作系统**流水线**机制的中断从而提升性能。指令重排也得满足**语义串行性**,但是没有义务保证多线程间的语义也一致(书上的例子是线程1给a赋值,线程2对a的值做修改,但是线程2有可能先执行)。
#### 哪些指令不能重排
##### 程序顺序原则
一个线程内保证语义的串行性
##### volatile规则
**volatile变量**的写,先发生于读,这保证了volatile变量的可见性
##### 锁规则
解锁(unlock)必然发生在随后的加锁前。
###### 传递性
a=b; b=c;  
A必然要先于C  
##### 线程的start()先于它的每一个动作
也就是说start方法会先执行。
##### 线程的所有操作先于线程的终结(Thread.join())
##### 线程的中断(interrupt())先于被中断线程的代码
##### 对象的构造函数执行、结束于finalize()方法
finalize()方法在JVM中看到过,可达性分析时会有一次标记,实例在finalize()方法中可以拯救自己一次(和可达链搭上关系)。
# 第二章 Java并行程序基础
## 有关线程必知的事
### 进程与线程
进程资源分配和调度的**基本单位**。
线程是程序的**最小执行单位**。
线程的状态6种，记住并且能说出具体干了什么。
## 初始线程：线程的基本操作
### 新建
### 中止
### 中断
### 等待(wait)与唤醒(通知 notify)
来自于Object的方法
### 挂起(suspend)与继续执行(resume)
### 等待线程结束(join)与谦让(yield)
## volatile与JMM(Java内存模型)
## 分门别类的管理(线程组)
## 驻守后台的线程(守护线程)
## 先干重要的事(线程优先级)
## 线程安全的概念与synchronized
## 程序中的幽灵(隐蔽的错误)
# 第三章 JDK下的并发包
## 同步控制
### synchronized的功能扩展ReentrantLock(可重入锁)
#### 中断响应
这里需要着重强调的是**lockInterruptibly()**方法,获取当前锁定,除非当前线程为interrupted。
如果锁没有被另一个线程占用并且立即返回,则将锁定计数设置为1。
如果当前线程已经保存此锁,则保持计数将递增1,该方法立即返回。
如果该锁被另一个线程保存，则当前线程将被禁用,并且处于休眠状态之一,直到发生两件事情之一:
1.锁是由当前线程获得的->则锁定保持计数器设置为1。
2.其他线程当前线程interrupts
#### 锁申请等待限时
#### 公平锁
#### ReentrantLock常用API
##### lock()
获得锁，如果锁已经被占用,则等待
##### lockInterruptibly()
获得锁,但优先响应中断
##### tryLock()
尝试获得锁,如果成功,返回true,失败返回false。该方法不等待,立即返回。
##### tryLock(long time,TimeUnit unit)
在给定时间内尝试获得锁
##### unlock()
释放锁
### 重入锁的搭档:Condition条件
#### 常用API
##### await()
使当前线程等待,同时释放当前锁,当其他线程中使用signal()或者signalAll()方法时,线程会重新获得锁并继续执行。线程中断时跳出等待。与Object.wait()方法类似
##### awaitUniterruptibly()
与await()基本类似，但是不会响应中断
##### singal()
用于唤醒一个在等待中的线程。与Object.notify()方法类似
#### ArrayBlockingQueue的put方法
### 允许多个线程同时访问:信号量(Semaphore)
#### 常用API
构造方法
##### public Semaphore(int permits)
##### public Semaphore(int permits,boolean fair)
构造信号量对象时,必须要指定信号量的**准入数**,即同时能申请多少个许可。如果每个只申请一个许可,相当于有多少个线程可以访问某一个资源。
逻辑方法
##### public void acquire()
尝试获取一个准入的许可,若无法获得
##### public void acquireUninterruptibly()
与acquire方法相似，不响应中断。
##### public boolean tryAcquire()
尝试获得一个许可,如果成功返回true，失败立即返回false。
##### public boolean tryAcquire(long timeout,TimeUnit unit)
##### public void release()
线程访问结束后，释放一个许可。
### ReadWriteLock读写锁
获取读锁
private static Lock readLock=readWriteLock.readLock();
获取写锁
private static Lock writeLock=readWriteLock.writeLock();
### 倒计时器CountDownLatch
顾名思义，计时器。书上举的例子的场景是火箭倒计时发射，火箭发射前要保证所有检查线程都结束。
#### 常用API
##### countDown()
##### CountDownLatch(int count)
### 循环栅栏:CyclicBarrier
阻止线程继续执行，要求线程在栅栏处等待。书上的场景是10个士兵一组去完成任务
但是书上的例子对于await()方法没有解释
#### 常用API
##### await()
等待所有parties已经在这个障碍上调用了await
### 线程阻塞工具类LockSupport
可以在线程内任意位置让线程阻塞。  
和Thread.suspend()相比,它弥补了由于resume()在之前发生导致线程无法继续执行的情况(第二章讨论的指令顺序的问题)  
和Object.wait()相比,它不需要先获得某个对象的锁,也不会抛出Interruption的异常。
#### 常用API
##### park()
阻塞当前线程
##### parkNanos()
##### parkUntil()
限时等待
## 线程复用:线程池
为什么使用线程池？
1. 创建和小会线程都会花费时间
2. 线程本身也会占用内存空间
所以,线程的使用必须掌握一个度,在有限的范围内,增加线程的数量可以明显提高系统的吞吐量
### 什么是线程池
和数据库连接池类似,维护一些数据库连接
### 不要重复发明轮子:JDK对线程池的支持
jdk提供了Executor框架，其本质就是一个线程池。
![](https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E6%88%AA%E5%B1%8F2022-08-23%20%E4%B8%8B%E5%8D%882.01.00.png)
上面的都是juc包中的核心类
ThreadPoolExecutor表示一个**线程池**。  
Executors类则扮演着**线程池工厂**的的角色,通过Executors可以取得一个拥有特定功能的线程池。
#### 常用API
##### public static ExecutorService newFixedThreadPool()
该方法返回一个固定线程数量的线程池, 有新的任务提交时，如果池中有空闲线程则立即执行。
##### public static ExecutorService newSingleThreadExecutor()
返回一个只有一个线程的线程池。多个任务提交的话，会有一个等待队列。
##### public static ExecutorService newCachedThreadPool()
返回一个可根据实际情况调整线程数量的线程池。如果空闲线程可以复用，则优先使用。如果没有线程可以复用，则创建新的线程。
##### public static ScheduledExecutorService newSingleThreadScheduledExecutorS()
返回一个ScheduleExecutorService对象，线程池大小为1，这个对象可以周期性执行某个任务。
##### public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)
也返回一个ScheduleExecutorService对象，但是可以指定线程数量。
### 核心线程池的内部实现
三种模式的线程池内部都实现了ThreadPoolExecutor
```java
public static ExecutorService newFixedThreadPool(int nThreads){
    return new ThreadPoolExecutor(nThreads,nThreads,0L,TimeUnit.MILLISECONDS,new LinkedBlokingQueue<Runnable>());
}
```
ThreadPoolExecutor最重要的构造函数
```java
public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,BlockingQueue<Runnable> workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler)
```
来看一下参数
corePoolSize:指定了线程池中的线程数量  
maximumPoolSize:指定了线程池中的最大线程数量   
keepAliveTime:当线程池数量超过corePoolSize时多余的线程存活的时间    
unit:keepAliveTime的单位    
workQueue:任务队列,被提交但尚未被执行的任务    
threadFactory:线程工厂,用于创建线程,一般用默认的即可   
handler:拒绝策略。当任务太多来来不及处理,如何
# 第四章 关于锁和锁的优化
对于多线程来说，系统除了处理功能需求以外，还需要维护和多线程相关的信息，例如，线程本身的**元数据**(???并不是很懂),线程的调度和线程上下问的切换。
这一章主要围绕如何优化锁来展开，采用的手段有：避免死锁、减小锁的粒度和锁分离等
## 提升锁性能的建议
### 减少锁的持有时间
书上举的例子是100个人排队填写表格，如果每个人都拿着笔才开始思考要填什么，那么话费时间肯定会过长。
对应到代码上应该进行如下优化(以jdk并发包中的正则表达式类Pattern为例)：
```java
public Matcher matcher(CharSequence input){
    if(!complied){
        synchornized(this){
            if(!complied){ //个人猜测为了一种可能为了线程安全，还有一种可能为了代码的健壮性
                complied();
            }
        }
    }
    Mathcer m=new Matcher(this,input);
    return m;
}
```
### 减少锁的粒度
这里以ConcurrentHashMap为例(还是1.7的版本,不过不影响学习其锁优化的过程)，其中最为重要的就是put方法和get方法，因为增删的时候最需要保证并发的安全性。
1.7采取的策略是在类内部又有16个HashMap,每个称之为段,这样一个实例的不同段就可被不同的线程持有。
下面这段是put方法(其中有一部分暂时还看不懂)
```java
 public V put(K key,V value){
    Segment<K,V> s;
    //先处理空指针
    if(value==null){
        throw new NullPointExeception();
    }
    //对key进行hash处理
    int hash=hsah(key);
    //获得对应的段的序号
    int j=(hash>>>segmentShift)&segmentMask;
    if((s=(Segment<K,V>)UNSAFE.getObject(segments,(j<<SSHIFT)+SBASE))==null){
        //上面的if进行了一次非可变性的检验，确保在确认的段里(过于拗口)
        s=ensureSegment(j);
    }
    return s.put(key,hash,value,false);
 }
```
但是另一个问题随之而来，就是在获取全局锁的时候消耗资源会更大。
ConcurrentHashMap中的size()方法就是获取全部的有效表项之和,为了达成这一目的，就需要去获取全部的锁,那么在计算时就需要对每个段进行加锁。
但是如果每次计算size的都需要加锁肯定消耗过大,所以首先用采用无锁的策略,只有失败之后才会尝试加锁。
综上:
只有size()这种全局方法调用不频繁时,加锁才能提供并发吞吐量。
### 读写分离锁来替换独占锁
这个之前有学习过，先掌握ReadWriterLock的API即可。
### 锁分离
在读写锁的思想上进一步延伸，就是锁分离。
根据应用程序的功能,采用类似锁分离的思想,将独占锁替换为可分离的锁。
书上的例子是BlockingLinkQueue这个数据结构，众所周知，所有的数据结构最基本的数据操作就是创建销毁和增删改查。从这个角度出发，将take()和put()用两个锁来分离。
```java
private final ReentrantLock takeLock=new ReentrantLock(); //被take,poll操作线程持有的锁

private final Conditional notEmpty=takeLock.newCondition();

private final ReentrantLock putLock=new ReentrantLock(); //被put,offer操作线程持有的锁。

private final Conditional notFull=putLock.newCondition();

```
take和put之间并不存在锁竞争的关系。
下面来看一下take方法的源码
```java

```


