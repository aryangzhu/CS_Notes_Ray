### c语言学习记录2

#### 枚举

#### 指针

指针也就是内存地址，指针变量是用来存放内存地址的变量，也就是说指针指向其他地址。
指针变量存储的还是它所在的内存的数值。
**如何使用指针**

```c
int var=20；//实际变量的声明
int *p;  //指针变量的声明
p=&var;   // &用来指引var的存储地址

printf("var变量的地址为%d",&var);

printf("p变量存储的地址%p\n",p);

printf("*p变量的值%d\n",*ip);
这个过程被称为间接访问内存
```

注意:在实现单链表初始化的过程中，如果将头节点指针L一开始为空指向别处的话，那么有可能会出问题，典型的问题就是

```c
int InsertList(LinkedList L,int i,int elem){
if(i==1){
        LNode *s=(LNode*)malloc(sizeof(LNode));
        s->data=elem;
        s->next=L;
        L=s;
        return 0;
    }
}
```

上面的代码从逻辑上来说是没有任何问题的，但是在调试过程中我们会发现,L最后在main函数的栈中指向的依旧是0x0(空指针),所以这里需要注意。换言之，就是当main()栈中的地址为其他地址时，那么引用传递就会成功，若是使用NULL,则需要将地址返回给main()栈。
动态分配内存

```
L.data=(ElemType *)malloc(sizeof(ElemType)* InitSize);
```

malloc动态分配内存，返回一个指向整块内存首地址的一个指针，同时需要进行强转将右边的数据类型转换成和左边一致。

##### 未初始化和非法的指针-易错点

```c
int a;
*a=120;
//我因为这个问题遭重，原因是只声明了指针指向内存的数值是多少，而没有声明地址在哪。
```

#### 函数指针与回调函数

#### 字符串

**常用库函数**
strcpy(s1,s2)-复制字符串s2到字符串s1的末尾
strcat(s1,s2)-连接s2到s1的末尾
strlen(s1)-返回s1的长度
strchr(s1,ch)-返回一个指针，指向字符串s1中字符ch的第一次出现的位置。
strstr(s1,s2)-返回一个指针，指向字符串s1中字符串s2的第一次出现的位置

#### 结构体

##### 定义结构体

```c
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;
```

如何定义带有*的结构体

```c
typedef strucut{
...
}LNode,*LinkList;
```

LinkList是一个指针类型，指向这个类型的结构。
**结构成员的间接访问**
->符号
例如L->length;
同时要理解的是**LinkList是类型名也就是说本质上就是(Struct *)==LinkList**,还是指向某块内存地址。所以才有我们今天写代码中的错误。
**警惕陷阱**

```c
typedef struct{
	Node * next;
}Node;
```

这种声明是非法的，为了保险起见应该使用如下形式

```c
typedef struct Node{
	Node * next;
}LNode;
```

#### 共用体
#### 位域