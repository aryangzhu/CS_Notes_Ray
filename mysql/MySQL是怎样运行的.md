---
html:
    toc: true
    # number_sections: true
    toc_depth: 6
    toc_float: true
        collapsed: true
        smooth_scroll: true
--- 
# 重新认识MySQL
## 客户端/服务器架构
## MySQL的安装
### bin目录下的可执行文件
bin目录下有好几种启动MySQL的可执行文件
## 启动MySQL服务器程序
### UNIX里启动服务器程序
1. mysqld 可以启动一个服务器进程
2. mysqld_safe  启动脚本,间接调用mysqld,顺便启动一个监控线程,在服务器进程挂了的时候，帮助重启。
3. mysql.server 启动脚本,间接调用mysql_safe,在调用mysql.server时在后边指定start参数就可以启动服务器程序。 mysql.server start
4. mysqld_multi 对每一个服务器进程的启动和停止进行监控
## 启动MySQL客户端程序
```shell
mysql -h主机名 -u用户名 -p密码
```
本上是一个进程间通信的过程
## 客户端与服务器连接的过程
### TCP/IP
如果使用TCP/IP网络来连接到服务器进程,就需要在启动客户端程序时在-h后面使用IP地址来作为需要连接的服务器进程所在主机的主机名。
## 服务器处理客户端的请求
# 启动选项和系统变量
## 启动选项和配置文件
### 在命令行上使用选项
例如,启动时禁止使用TCP/IP网络通信。  
```shell
mysql --skip-networking
```
指定启动选项时需要加上--前缀。另外如果选项名是由多个单词构成的,他们之间可以由短划线-连接起来。比如,skip-networking和skip_networking表示的含义是相同的。
还有一个例子是启动时设置表的存储引擎  
书上还强调了一下选项的长形式和短形式,例如--host -h主机名这样式儿的
### 配置文件使用选项
因为启动时命令行选项只在本次起作用,所以放在配置文件中永久生效
#### 配置文件路径
这块对于类unix的路径进行描述
#### 配置文件内容
分组进行配置,各个启动命令也有能读取的组的限制。
注:如果同一个启动选项即出现在命令行中,又出现在配置文件中,那么以命令行的启动选项为准。
## 系统变量
### 简介
在服务器程序运行过程中能对其造成影响的变量。
### 查看系统变量
```shell
show variables like 'default_storage_engine'
```
### 设置系统变量
#### 通过启动选项设置
#### 服务器运行过程中设置
##### 设置不同作用范围的系统变量
书上提到了两个概念或者说是两个范围,一个是global,另一个是session。
1. GLOBL:全局变量,影响服务器的整体操作  
2. SESSION:会话变量,影响某个客户端连接的操作  
服务器启动时,会将每个全局变量初始化为其默认值。服务器会为每个客户端连接维护一组会话变量,客户端的会话变量在连接时使用相应全局变量的当前值初始化。
如果在设置系统变量的语句中省略了作用范围,**默认的作用范围就是SESSION**(这次的客户端连接)。  
##### 查看不同作用范围的系统变量
同样也是使用show varaibles like 'default_storage_engine'
## 状态变量
为了检测服务器程序的运行情况而存在的变量,由此而知,它们的值是由服务器程序来设置的。
show status like 'thread%'  
状态变量也有global和session两个作用范围。
# 字符集和比较规则
## 字符集和比较规则介绍
### 字符集简介
将二进制数据转换为字符所用的这套转换规则就是字符集
### 比较规则简介
a-0x01 b-0x02   
上面的字符如果以二进制数据自身的比较规则来进行比较的话,那么大多数时候是不符合场景需求的。  
'a'和'A'进行比较时:
1. 将两个大小写不同的字符全部转换为大写或者小写  
2. 再比较这两个字符对应的二进制数据。
## 字符集和比较规则的应用
### 各级别的字符集和比较规则
### 客户端和服务器通信过程中使用的字符集
### 比较规则的应用
## 总结
1. 字符集
2. 比较规则
3. 在MySQL中,一个字符集可以有若干种比较规则,其中有一个默认的比较规则,一个比较规则必须对应一个字符集
4. 查看MySQL支持的字符集和比较规则语句:
show (charcter set|charset)[like 匹配的模式]  
show collation [like 匹配的模式]  
5. MySQL有四个级别的字符集和比较规则
   + 1 服务器级别
   + 2 数据库级别
   + 3 表级别
   + 4 列级别
---
6. 从发送请求到接收结果过程中发生的字符集转换
7. 比较规则的作用通常体现在比较字符串大小的表达式和对某个字符串进行排序中
# InnoDB记录存储结构
虽然书上已经讲得十分通俗了,奈何我学的还是非常吃力,找了一篇博客,觉得还不错。  
https://draveness.me/mysql-innodb/
## 简介
将数据划分为若干个页,以页作为磁盘和内存之间交互的工作单位,InnoDB中页的大小一般为16KB.
## Compact格式
## Redundant行格式
## 两者的异同
最大的不同就是compact在行记录的第一部分倒序存放了一行数据中列的长度(Length),而Redundant中存的是每一列的偏移量(Offset)
## 行溢出数据
当InnoDB使用Compact或者Redundant格式**存储极长的VARCHAR或者BLOB这类大对象时**,我们**并不会直接将所有的内容都存放在数据页节点中**,而是将行数据中的前768个字节存储在数据页中,后面会通过偏移量指向溢出页。  
当使用新的记录格式Compressed或者Dynamic时都会只在行记录中保存20个子节的指针,**实际的数据都会存放在溢出页面中**。
# InnoDB数据页结构
## 不同类型的页
为了不同的目的设计了许多种不同类型的页,比如存放头部信息的页,存放Insert Buffer信息的,存放index信息的页,存放undo日志信息的页等
## 数据页结构的快速浏览
数据页代表的这块16KB大小的存储空间可以被划分多个部分,不同的部分有不同的功能  
1. File Header
2. Page Header
3. Infimum+supremum 两个虚拟的行记录 最大记录和最小记录
4. User Records 真实存储行记录内容
5. Free Space
6. Page Directory 页中的某些记录的相对位置  
7. File Tailer
## 记录在页中的存储
不得不再提及一下记录的构成,下面展示了行记录的记录头格式
### 记录头的构成
1. 预留位1
2. 预留位2
3. delete_mask 标记该记录是否被删除  
4. min_rec_mask B+树的每层非叶子结点的最小记录
5. n_owned 表示当前拥有的记录数
6. heap_no 表示当前记录在记录堆中的位置
7. record_type 表示当前记录的类型
8. next_record 表示下一条记录的相对位置   
其中比较重要的3个字段n_owned、heap_no和next_record书上讲的非常的详细
## Page Directory(页目录)
## Page Header(页面头部)
## File Header(文件头部)
## File Trailer(文件尾部)
## 总结
1. InnoDB为了不同的目的设计了不同类型的页,我们把用于存放记录的页叫做数据页
2. 数据页大致被分为7个部分:
- File Header 表示页的一些通用信息,占固定的38字节
- PageHeader 表示数据页专有的一些信息,占固定的56个字节
- Infimum+Supremum 两个虚拟的伪记录,分别表示页中的最小和最大记录,占26个子节
- User Records 真实存储我们插入的记录的部分,大小不固定
- Free Space 页中尚未使用的部分
- Page Diretory 页中某些记录的位置,对于数据页来说是每一组的最后一条记录
- File Trailer 用于检验数据页是否完整(备份到磁盘过程断电的检验)
3. 记录会形成单链表
4. 查找记录的过程(必须完全理解)  
提示:Page Directory+二分+next_record
5. FileHeader会使得所有数据页组成一个**双链表**
6. 校验和以及LSN值
# B+树索引
通过前面的学习我们知道查询到记录是存放在数据页中的,通过FileHeader和FileTrail将其连接为一个双向链表。数据记录是next_record指针连接起来的链表。
## 为什么需要索引
暴力遍历:从最小记录开始遍历  
二分法:根据数据页记录槽中的数据来快速定位到(这是在数据页中快速查找)  
如何快速找到是哪个数据页
这个时候就需要借助某种数据结构来帮助我们快速定位到数据页  
页分裂
## 先从简单的索引方案开始
为每个数据页建立一个目录项,这些目录项页保存在数据页中,目录项的格式为key-value,key用的是主键id,value保存的是页的地址(书上用的名词叫做页号),通过目录项可以快速的访问到页。
## InnoDB中的索引方案
上面的方案有一个痛点就是数据页的大小只有16KB,如果用户记录很多的时候那么目录项也会有很多,这个时候会有多个存储目录项的数据页,又遇到了找哪个页的问题。  
所以,InnoDB采用了树结构的方式来保存目录项和用户记录(记录格式中有个属性叫做record_type),而这种数据结构也被称为B+树  
### 聚簇索引
B+树本身就是一个聚簇索引,也就是说索引和数据都在树中,且叶子结点保存用户记录。
### 二级索引
用某个列作为目录项,叶子结点存储的的是主键,拿到主键之后还要去聚簇索引中查记录,这个过程称为回表
### 联合索引
多个列构成的二级索引
## InnoDB的B+树索引的注意事项
1. 根结点不移动,移动的是页中的数据
2. 内节点(除去叶子节点)目录项记录的唯一性
3. 一个页面最少存储2条记录
## MyISAM中的索引方案简单介绍
索引与数据是分开,索引信息会存储在被称为索引文件的文件中。MyISAM会单独为表的主键创建一个索引,存储的是主键和行号。
## 创建和删除索引的语句
在建表时创建索引
```mysql
create table index_demo{
    c1 int,
    c2 int,
    c3 char(1),
    primary key(c1), 
    index idx_c2_c3 (c2,c3)
}
```
修改表来添加索引
```mysql
alter table table_name add [index|key] 索引名(需要被索引的单个列或多个列)
```
删除时使用drop
# 学会使用B+树索引
## 索引的代价
## B+树索引的适用条件
### 全值匹配
索引的每个列都用到了,这种情况被称为全值匹配
### 匹配左边的列
用到了联合索引中的左边的列
### 匹配前缀
```mysql
SELECT * FROM person_info WHERE name LIKE 'As%';
```
可以看到根据前缀进行了匹配,在索引的排序也是这样的,在索引变动时某个列也会根据字母顺序排序  
### 匹配范围值
```mysql
select * from person_info where name >'Asa' and name<'Barlow';
```
找到name的值为Asa的记录  
找到name的值为Barlow的记录  
拿到中间的所有记录  
### 精确匹配某一列并范围匹配另一列
精确匹配到的列必须是最左边的列
### 用于排序
```mysql
select * from person_info order by name,birthday,phone_number limit 10;
```
注意:排序的列必须要和联合索引的列的顺序保持一致
### 用于分组
```mysql
select name,birthday,phone_number,count(*) from person_info group by name,birthday,phone_number
```
不出意料的是索引也会生效,因为首先会找到最左边的列,然后再按联合索引后面的索引进行分组。
# MySQL的数据目录
## 文件系统
操作系统用来管理磁盘的叫做**文件系统**
## MySQL数据目录
### 安装目录与数据目录
安装目录的话一开始就说过这个文件,下面的bin目录有许多可执行文件;数据目录是用来存储运行过程中产生的数据
### 如何查看数据目录
show variables like 'datadir';
## 数据目录的结构
### 数据库在文件在文件系统中的表示
新建数据库时会在数据目录下产生一个子目录
### 表文件在文件系统中的表示
我在自己电脑上没有发现与书上一致的表结构文件和表数据文件,只有一个.ibd文件
#### 表结构文件
#### 表数据文件
##### 系统表空间
5.5.7-5.6.6之间的时候,数据会被存储到系统表空间,我在电脑上试了一下并不是一个文件夹,同时在启动的时候也可以配置系统表空间的位置和大小
##### 独立表空间
MySQL5.6.6之后数据会被存储到独立表空间  
我们自己可以指定是否使用独立表空间还是系统表空间
#### MyISAM是如何存储数据的
表结构、索引(在介绍索引时有提到过)和表数据三者分开存储  
test.frm test.MYD  test.MYI  
### 试图在文件系统中的表示
虚拟表,所以只用存储表结构文件
### 其他的文件
服务器进程文件:MySQL服务器会把自己的进程ID写入到一个文件中  
服务器日志文件:各种日志文件,例如查询日志、错误日志、二进制日志和redo日志
默认/自动生成的SSL和RSA证书和密钥文件:为了客户端和服务器端的安全通信而创建的一些文件
## 文件系统对数据库的影响
数据库收到文件系统的约束  
数据库名称和表名不能超过文件系统所允许的最大长度  
表结构文件中会有特殊字符
文件长度受到文件系统最大长度限制
# 存放页面的池子-InnoDB的表空间
这一章的内容可能难以理解,所以需要借助图片来更加直观的展示
## 复习有关页的知识
### 页面类型
书上大概讲了一下这部分,我听的多的是Undo日志页
### 页面通用部分
#### FileHeader的组成部分
书中对于各个组成部分描述  
FIL_PAGE_OFFSET 页号
## 独立表空间
用书上的例子来说的话,表空间就是一个军团,段就是一个个师,而区既可以隶属于师,也可以直接作为独立团属于表空间  
### 区(Extend)
区是由物理上的64个页组成的,具有物理存储结构  
256个区构成一个组,独立表空间中第一组的前三个页是特殊的,它的内容是固定的  
FSP_HDR:表空间整体属性和本组所有的区  
IBUF_BITMAP:???
INODE:还是没理解这块儿
#### 为什么引入区？
避免随机I/O
### 段
为什么引入段的概念? 
书上的理由是为了区分叶子结点和非叶子结点(在范围扫描时起作用),为什么区分了就快???  
所以将索引的叶子结点与非叶子结点区分(逻辑上的，至于物理上的肯定还是通过链表连接)  
为了节省空间同时就有了碎片区这一概念,直属于表空间,有些页用于段A,有些页用于段B。  
此后,为某个段分配存储空间的策略:
1. 在刚开始向表中插入数据的时候,段是从某个碎片区以单个页面为单位来分配存储空间
2. 当某个段已经占用了32个碎片页的时候,就会以完整的区为单位来分配存储单位  
### 区的分类
空闲的区(FREE):未使用的区 
有剩余空间的碎片区(FREE_FRAG):表示碎片区中还有可用的页面
没有剩余空间的碎片区(FULL_FRAG):已经完全被使用
隶属于某个段的区(FSEG):之前提到过如果某个区被分配给某个段的情况
FREE、FREE_FLAG和FULL_FLAG都是直属于表空间的  
**XDES Entry()**的结构,是这一章出现的第一种结构(数据结构),其中有个组成部分就是**ListNode**,链表,用来将多个XDES Entry连接起来
与上面3种类型对应的就是FREE链表、FREE_FRAG链表和FULL_FRAG链表
上面提到过给段分配存储空间如果占用了超过32个碎片页的时候就会分配完整的区,结合3种类型的链表,无非就是修改链表的next node指针操作了
#### 哪些区属于哪个段
上面的问题针对于碎片区来说的,那么段中的页是什么情况?  
每个段有三个链表:FREE、NOT_FULL和FULL链表
假设一个表有两个索引,共需维护15个链,段在数据量比较大时插入数据的话,会先获取NOT_FULL链表的头节点,直接将数据插入这个头节点对应的区中即可,如果该区的空间使用完则会被移到FULL链表中。  
#### 链表基节点
如何找到某个XDES Entry,这个时候用的就是List Base Node
### 段的结构
ListNode链表
### 各类型页面详细情况
前面讲了那么多链表,那么它们的List Base Node在哪儿呢?
#### FSP_HDR类型
##### File Space Header
3种类型的List Base Node  
Free Limit 
### Segment Header
用来区分叶子结点和非叶子结点
### 真实表空间对应的文件大小
.ibd自扩展,随着表中的数据的增多,表空间对应的文件也逐渐增大
## 系统表空间
和独立表空间类似,但是比表空间在第一组中多了三个页
![](https://raw.githubusercontent.com/aryangzhu/blogImage/master/%E6%88%AA%E5%B1%8F2022-10-28%20%E4%B8%8B%E5%8D%883.21.37.png)  
# 单表访问方法
在此之前,书上有建了一个表,这是前提。  
在执行一条SQL语句的时候有多种方案,MySQL Server有个**查询优化器**的模块,这个模块最终会将查询语句优化成一个所谓的**执行计划**,执行计划后面会详细讲解,现在先有这么一个概念。
## 执行方法(access method)
MySQL的**查询方式**大致有两种:  
* 使用全表搜索
* 使用索引进行查询,可以细分为很多种类
    * 针对主键或唯一二级索引的等值查询(唯一)
    * 针对普通二级索引的等值查询(范围)
    * 针对索引列的范围查询(范围)
    * 直接扫描整个索引
针对上面的这几种细分的查询方式,MySQL将其称为**访问方法**或者**访问类型**。  
## const(常量级别)
指的就是针对主键或者唯一二级索引,执行几次二分查询就可得到数据,所以就是const
## ref
```mysql
select * from single_table where key1='abc'
```
搜索条件为二级索引与常数值等值比较,采用二级索引来执行查询的访问方法称为:ref。  
## ref_or_null
与上面的差别是将NULL的等值也包括了
## range
上面说的都是等值查询,那么如果是范围查询的情况该是什么样子呢？ 
索引列会匹配范围内的值(等值匹配)  
## index
不需要回表,通过查询二级索引即可获取全部的数据
## all
## 注意事项
### 二级索引+回表
### 明确range范围
上面的访问方法中range看起来是执行起来最复杂的一个,下面就是MySQL的一些优化手段  
#### 所有搜索条件都可以使用某个索引的情况
直接使用二级索引就可以确定所有查询的值
#### 有的查询条件无法使用索引的情况
```mysql
select * from single_table where key2>100 and common_field='abc'
```
key2>100查询条件可以使用idx_key2来进行匹配,后面的查询条件则无法使用索引。此时将后面的查询条件设置为true,直接根据前面的条件查询到记录。然后在回表的时候再根据common_field的条件进行过滤。
#### 复杂搜索条件下找出范围匹配的区间
复杂条件其实也可以进行化简,能够用聚簇索引的话肯定就会使用聚簇索引,减少回表的操作。
### 索引合并
一般一次查询只会使用单个二级索引,但是特殊情况下也可能在一个查询中使用到多个二级索引
#### Intersection合并
AND关系  
多个二级索引查询的结果**取交集**再回表
##### 适用情况
1. 二级索引等值匹配
2. 主键列范围匹配(主键列指定范围,二级索引等值)
#### Union合并
OR关系  
取并集
##### 适用情况
1. 二级索引等值匹配
2. 主键列范围匹配(主键列指定范围,二级索引等值)
3. 取交集的索引合并的搜索条件
#### Sort-Union合并
二级索引范围匹配(这种情况有点玄乎),对主键进行排序。
# 连接的原理
##  连接简介
### 连接的本质
### 连接过程
**驱动表**
笛卡尔乘积在多表时的排列组合结果指数级增长,所以就有了左连接和右连接。首先需要明确的是驱动表的概念,就是最先满足查询的条件的表,像左连接就是左边的表就是驱动表。
**被驱动表**
在驱动表中查完数据之后,需要到被驱动表中去找满足连接条件和其他条件的数据,这类表被称为被驱动表。
### 内连接和外连接
#### 区别
对于内连接来说,驱动表在被驱动表中找不到匹配的记录,那么就不会加入到结果集中。  
对于外连接来说,<font color="red">驱动表的记录即使在被驱动表中没有匹配的记录,也仍然需要加入到结果集中</font>
#### where过滤条件与on过滤条件
对于外连接来说,on会将不匹配加入,而where都不会加入
## 连接的原理
### 嵌套循环连接
驱动表只访问一次,被驱动表访问的次数取决于对驱动表执行单表查询后的结果集中的记录条数,这种方式称之为**嵌套循环连接(Nested-Loop Join)**
### 使用索引加快查询速度
从驱动表中到被驱动表中查数据的时候相当于一次条件查询,那么这个时候就可以**使用索引**加快查询的速度。
### 基于块的循环嵌套连接
总结:  
1.内连接和外连接
2.MySQL的设计者总想用更少的资源和更快的访问速度来提升查询的效率,把握住这个就是这几章的思想
# MySQL基于成本的优化
## 什么是成本
CPU成本和I/O成本?
从磁盘加载到到内存过程的损耗的时间称为**I/O成本**
读取及检测结果是否满足对应的搜索条件、对结果集进行排序等操作称为**CPU成本**;
## 单表查询的成本
### 基于成本的优化步骤
在一条单表查询语句真正执行之前,MySQL的查询优化器会找出所有可能使用的方案,然后选择一个成本最低的方案,这个成本最低的方案就是所谓的**执行计划**,过程如下
1.根据搜索条件,找出所有可能使用的索引  
2.计算全表扫描的代价  
3.计算使用不同索引执行查询的代价  
4.对比各种执行方案的代价,找出成本最低的那一个
#### show index
Non_unique 索引列的值是否唯一  
Seq_in_index 索引列在索引中的位置
Collation 索引列中的值是按何种排序方式存放的,值为A时代表升序存放  
Cardinality 索引列不重复值的数量  
Sub_part 对于存储字符串或者字节串来说,只想对前n个字符或字节建立索引
### 连接查询的成本
**扇出**:从驱动表进行查询后的记录条数称为驱动表的**扇出**,这个概念有什么用呢,肯定跟被驱动表有关系呗
### 调节成本常数
server层和存储引擎层,在server层进行**连接管理、查询缓存、语法解析和查询优化等操作,在存储引擎层执行具体的数据存取操作。
1.mysql.server_cost表
2.mysql.engine_server表
# InnoDB的统计数据如何收集
上一章中有个index dive的概念,就是从索引的B+树中查询满足条件的索引记录的过程。但是这种情况在某些情况下(书上举的例子是在in中的参数非常多)就会非常慢,还有一种方案就是靠MySQL的统计数据,但是误差非常大。  
## 两种不同的统计数据存储方式
1.永久性的统计数据  
2.非永久性的统计数据  
InnoDB是**以表为单位**来收集和存储统计数据的。我们可以在创建和修改表的时候通过指定
STATS_PERSISTENT属性来指明表的统计数据存储方式:
alter table 表名 Engine=InnoDB,STATS_PERSISTENT=0
## 基于磁盘的永久性统计数据
实际上将这些统计数据存储到了两个表里:  
**innodb_table_stasts**  每一条记录对应着一个表的统计数据   
**innobb_index_stats**  每一条记录对应着一个索引的统计项的统计数据  

   




